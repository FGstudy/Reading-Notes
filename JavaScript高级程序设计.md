<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [js 高级程序设计](#js高级程序设计)
  - [在 HTML 里使用 js](#在html里使用js)
    - [script 元素](#script元素)
      - [标签的位置](#标签的位置)
    - [嵌入代码和外部文件](#嵌入代码和外部文件)
    - [文档模式](#文档模式)
    - [noscript 元素](#noscript元素)
  - [基本概念](#基本概念)
    - [语法](#语法)
      - [区分大小写](#区分大小写)
      - [标识符，指变量、函数、属性的名字或者函数的参数](#标识符指变量-函数-属性的名字或者函数的参数)
      - [注释](#注释)
      - [严格模式](#严格模式)
      - [语句，以分号为结尾](#语句以分号为结尾)
    - [关键字与保留字，查表吧](#关键字与保留字查表吧)
    - [变量](#变量)
    - [数据类型](#数据类型)
      - [typeof 操作符](#typeof操作符)
      - [undefined](#undefined)
      - [null](#null)
      - [boolean](#boolean)
      - [number](#number)
      - [string](#string)
      - [object](#object)
    - [操作符](#操作符)
      - [一元操作符](#一元操作符)
      - [位操作符，先简单了解](#位操作符先简单了解)
      - [布尔 Boolean](#布尔boolean)
      - [\* / %](#)
      - [+ -](#-)
      - [关系操作符< > <= >=](#关系操作符)
      - [相等操作符](#相等操作符)
      - [条件操作符（三元运算符）](#条件操作符三元运算符)
      - [赋值操作符=，把右侧的值赋给左侧的变量](#赋值操作符把右侧的值赋给左侧的变量)
      - [逗号操作符](#逗号操作符)
    - [语句](#语句)
      - [if 语句](#if语句)
      - [do-while 语句](#do-while语句)
      - [while 语句](#while语句)
      - [for 语句](#for语句)
      - [for-in 语句](#for-in语句)
      - [label 语句（？）](#label语句)
      - [break 和 continue 语句](#break和continue语句)
      - [with 语句](#with语句)
      - [switch 语句](#switch语句)

<!-- /code_chunk_output -->

# js 高级程序设计

## 在 HTML 里使用 js

### script 元素

#### 标签的位置

1. 把 script 元素放在 head 元素中，必须等到全部 js 代码被下载，解析，执行完成之后才能开始呈现页面的内容，这样可能会导致浏览器在呈现页面时出现延迟，所有现在一般把 script 元素放在 body 里面，这样在解析 js 代码前页面的内容就可以呈现。
2. script 元素的 defer 属性，只适用于外部脚本，作用是让浏览器立即下载但延迟执行，即使将 script 元素放在 head 里面，脚本也会延迟到浏览器

遇到 html 标签再执行，但最佳选择还是将脚本放在页面底部

3. script 元素的 async 属性，只适用于外部脚本，作用是不让页面等待脚本下载和执行，从而异步加载页面其他内容，异步脚本一定会在页面的 load 事件前执行，建议异步脚本不要在加载期间修改 DOM，

### 嵌入代码和外部文件

1. 使用外部文件的优点：

- 可维护性
- 可缓存，浏览器能够根据具体的设置缓存链接的所有外部 js 文件
- 适应未来

### 文档模式

1. 混杂模式和标准模式，如果文档开始处没有声明文档类型则默认开启混杂模式

### noscript 元素

1. noscript 早期浏览器为了让页面能够平稳退化创造出的元素，用以在不支持 js 的浏览器中显示替代内容，元素内的内容只有在浏览器不支持脚本或者脚本被禁用时显示

## 基本概念

### 语法

#### 区分大小写

#### 标识符，指变量、函数、属性的名字或者函数的参数

1. 命名规则：

- 第一个字符必须是一个字母、下划线_、或者美元符号，其他字符可以是字母、下划线、美元符号、数字
- 采用驼峰式命名
- 不能使用关键字、保留字、true、false、null

#### 注释

1. 单行注释//
2. 多行注释/\*\*/

#### 严格模式

1. 在严格模式下，es3 的一些不确定行为将得到处理，对某些不安全的操作也会抛出错误
2. 使用严格模式，需要在顶部或者函数内部的上方增加一条编译指示"use strict"

#### 语句，以分号为结尾

### 关键字与保留字，查表吧

### 变量

1. js 的变量可以用来保存任何类型的数据，变量可以说是一个用于保存值的占位符。
2. 用 var 定义的变量是定义该变量的作用域中的局部变量，例如在函数内用 var 声明一个变量，在函数外部不能使用该变量，如果不用 var 声明则可以使用，虽然省略 var 操作符可以定义全局变量，但是不推荐使用
3. 用一条语句定义多个变量时，用逗号分割开即可

### 数据类型

es5 中有 5 种基本数据类型：undefined,null,number,string,boolean,和 1 种复杂数据类型 object

#### typeof 操作符

1. typeof 可以操作变量或者数值字面量，
2. typeof(null)，返回 object，因为 null 被认为是一个空的对象引用

#### undefined

1. 使用 var 声明变量但是未对其加以初始化时，该变量的值为 undefined
2. 对未初始化或未声明的变量执行 typeof 都会返回 undefined

#### null

1. 从逻辑角度，null 值表示一个空对象指针
2. 如果定义的变量将来要用于保存对象，那么最好将该变量初始化为 null 而不是其他值
3. null == undefined 返回 true

#### boolean

1. 字面值：true false
2. 调用 Boolean()函数，其他类型数据转换成 Boolean 的值

- string，任何非空的字符串转为 true，空字符串转为 false
- number，任何非零数字值转为 true，0 或 NaN 转为 false
- object，任何对象都会转为 true，null 转为 false
- undefined 转为 false

#### number

1. 除了十进制表示外，整数还可以用八进制或十六进制来表示，其中八进制字面值的第一位必须是 0，然后是 0~7，十六进制字面值的前两位必须是 0x，后跟 0~9 或 A~F 或 a~f，但在进行算数计算时，所以进制表示的数最后都会转换成十进制数值
2. 浮点数，即数值中包含一个小数点，而且小数点后必须有一个数字

- 浮点数需要的内存空间是整数的两倍，es 会将适当的浮点数转换成整数
- 对于极大或极小的数字可以用科学记数法，用 e 表示的数值等于 e 前面的数值乘以 10 的指数次幂，例如 3.15e7=3.15\*10 的七次方=3150000
- 默认情况下 es 会将小数点后面带有 6 个 0 以上的浮点数转换成科学记数法表示
- 浮点数的最高精度是 17 位小数，但在进行算数计算时，其精确度不如整数，例如 0.1+0.2 结果不是 0.3，而是 0.30000000000000004

3. 数值范围

- es 能表示的最小数值保存在 Number.MIN_VALUE 中，最大数值保存在 Number.MAX_VALUE 中
- 如果超出数值范围，这个数值将被自动转换成特殊的 infinity 值，该值将不能参与下一次计算
- isinfinite()函数可以判断一个数值是不是有穷的

4. NaN， not a number

- 表示一个本来要返回数值的操作数没有返回数值的情况，
- 任何涉及 NaN 的操作都会返回 NaN，例如 NaN / 10
- NaN 和任何值都不相等，包括 NaN 本身
- isNaN()可以传入一个参数，该函数可以判断参数是否不是数值，并会对传入的参数进行转换，如果不能转换的返回 true，能转换成数值返回 false
- isNaN()也适用于对象，它会先调用对象的 valueOf 方法，然后再确认该方法返回的值是否可以转为数值，如果不能再基于这个返回值再调用 toString()方法在测试返回值

5. 数值转换
   能将非数值转换成数值有三个函数：Number(),parseInt(),parseFloat()

- Number(),可以用于任何数据类型 + 转换规则 + 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。 + 如果是数字值，只是简单的传入和返回。 + 如果是 null 值，返回 0。 + 如果是 undefined，返回 NaN + 如果是字符串，遵循下列规则： + 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"会变成 1，"123"会变成 123，而"011"会变成 11（注意：前导的零被忽略了） + 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽略前导零）； + 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值； + 如果字符串是空的（不包含任何字符），则将其转换为 0； + 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。 + 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。
- parseInt() + 解析过程，它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回 NaN；也就是说，用 parseInt()转换空字符串会返回 NaN（Number()对空字符返回 0）。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。也就是返回字符串以整数开头的部分 + 它可以识别十六进制和八进制，如果字符串以"0x"开头且后跟数字字符，就会将其当作一个十六进制整数；如果字符串以"0"开头且后跟数字字符，则会将其当作一个八进制数来解析。注意在 es5,不能直接解析八进制数值 + 可以将使用什么进制传入该函数的第二个参数内，以消除八进制与十进制可能会造成的矛盾
- parseFloat()与 parseInt()类似，不过返回的是浮点数，不过要注意如果如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数

#### string

1. 字符字面量

- 一些转义字符 + \n，换行 + \t，制表符 + \b，空格 + \r，回车 + \\，斜杠 + \'，单引号 + \"，双引号

2. 字符串的特点

- 字符串一旦创建，他们的值就不能改变，如果要改变要先销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，例如

```
var lang = "java";
lang = lang + "s"；
```

3. 转换成字符串的方式

- toString()方法，注意 null 和 undefined 没有这个方法，一般就用点调用，需要指定进制时，将进制作为参数传入小括号
- 转型函数 String()，函数能够将任何类型的值转换为字符串，规则 + 如果值有 toString()方法，则调用该方法（没有参数）并返回相应的结果； + 如果值是 null，则返回"null" + 如果值是 undefined，则返回"undefined"。
- 使用连接符

#### object

1. 对象是一组数据和功能的集合
2. 对象的创建：通过 new 后跟要创建的对象类型的名称，例如 ,如果不给构造函数传参，可以省略小括号，但是不推荐省略

```
var obj = new object();
var obj = new object;//有效，但不推荐省略小括号
```

3. 类似 Java，object 类是所有对象的基类，它的所有属性和方法都适用于所有对象，所以 object 的每个实例都具有以下属性和方法

- constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object()。
- hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty("name")）。
- isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型
- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句来枚举。，与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString()：返回对象的字符串表示。
- valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。

4. 注意浏览器对象即 BOM,DOM 对象属于宿主对象，在 ECMA-262 中不负责定义宿主对象，因此宿主对象可能会也可能不会继承 object

### 操作符

#### 一元操作符

1. 递增和递减，++和--，

- 符号++如果单独使用，放前放后是一样的
- 符号++如果在表达式中使用，放前放后不是一样的 + 符号++，如果放前先+1，在用新值参与表达式， + 如果放后面，先用旧值参与表达式，表达式结束后再+1
- 该操作符对任何值都适用，规则： + 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。 + 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN，字符串变量变成数值变量。 + 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。 + 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。 + 在应用于浮点数值时，执行加减 1 的操作。 + 在应用于对象时，先调用对象的 valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN，则在调用 toString()方法后再应用前述规则。对象变量变成数值变量。

2. 一元+或-

- 一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响
- 对非数值应用一元加操作符时，该操作符会像 Number()转型函数一样对这个值执行转换。例如

```
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;

s1 = +s1; // 值变成数值 1
s2 = +s2; // 值变成数值 1.1
s3 = +s3; // 值变成 NaN
b = +b; // 值变成数值 0
```

- 一元减操作符主要用于表示负数，当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数

#### 位操作符，先简单了解

#### 布尔 Boolean

1. 逻辑非! ，无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。
   - 规则 + 如果操作数是一个对象，返回 false；  
      + 如果操作数是一个空字符串，返回 true； + 如果操作数是一个非空字符串，返回 false；  
      + 如果操作数是数值 0，返回 true； + 如果操作数是任意非 0 数值（包括 Infinity），返回 false； + 如果操作数是 null，返回 true； + 如果操作数是 NaN，返回 true； + 如果操作数是 undefined，返回 true。
   - 使用两次逻辑非运算符相当于 Boolean()转型函数
2. 逻辑与&&，两者都为真时则为真
   - && 可以应用于任何类型的操作数，。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值，规则如下 + 如果第一个操作数是对象，则返回第二个操作数； + 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象； + 如果两个操作数都是对象，则返回第二个操作数； + 如果有一个操作数是 null，则返回 null； + 如果有一个操作数是 NaN，则返回 NaN + 如果有一个操作数是 undefined，则返回 undefined。
   - 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值
   - 不能在逻辑与操作中使用未定义的值。如果第一个值为 false，那第二个值才可以使用未定义的值
3. 逻辑或||，一个为真则为真
   - 与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值，规则 + 如果第一个操作数是对象，则返回第一个操作数； + 如果第一个操作数的求值结果为 false，则返回第二个操作数 + 如果两个操作数都是对象，则返回第一个操作数 + 如果两个操作数都是 null，则返回 null + 如果两个操作数都是 NaN，则返回 NaN + 如果两个操作数都是 undefined，则返回 undefined。
   - 逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为 true，就不会对第二个操作数求值了
   - 不能在逻辑或操作中使用未定义的值。如果第一个值为 true，那第二个值才可以使用未定义的值
   - 利用逻辑或，可以避免为变量赋 null 或 undefined 值，例如
   -

```
var myObject = preferredObject || backupObject;
//如果 preferredObject 的值不是 null，那么它的值将被赋给 myObject；如果是 null，则将 backupObject 的值赋给 myObject
```

#### \* / %

1. 乘法\*，处理特殊值时规则如下
   - 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity；
   - 如果有一个操作数是 NaN，则结果是 NaN；
   - 如果是 Infinity 与 0 相乘，则结果是 NaN；
   - 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
   - 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；
   - 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。
2. 除法/，处理特殊值时规则如下
   - 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity；
   - 如果有一个操作数是 NaN，则结果是 NaN；
   - 如果是 Infinity 被 Infinity 除，则结果是 NaN；
   - 如果是零被零除，则结果是 NaN；
   - 如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
   - 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号
   - 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则
3. 取模%，处理特殊值时规则如下
   - 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
   - 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN；
   - 如果被除数是有限大的数值而除数是零，则结果是 NaN；
   - 如果是 Infinity 被 Infinity 除，则结果是 NaN
   - 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数
   - 如果被除数是零，则结果是零；
   - 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。

#### + -

1. 加法+：如果两个操作符都是数值，执行常规的加法计算，如果有一个操作数是字符串，则执行拼接操作，如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。
2. 减法-：规则如下
   - 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果，
   - 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN；
   - 如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法并将得到的字符串转换为数值。

#### 关系操作符< > <= >=

1. 规则：
   - 如果两个操作数都是数值，则执行数值比较。
   - 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
   - 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
   - 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比 较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。
   - 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。
   - 何何操作数与 NaN 进行关系比较，结果都是 false
2. 特殊情况，比较两个字符串时，比较的是两个字符串中对应位置的每个字符的字符编码值，例如当比较字符串"23"是否小于"3"时，结果是 true。。

#### 相等操作符

1. 相等与不相等（==与!=），这两个操作符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。
   - 基本规则： + 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而 true 转换为 1； + 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值； + 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较； + 这两个操作符在进行比较时则要遵循下列规则。 + null 和 undefined 是相等的。要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。 + 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true，即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN。 + 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false。
2. 全等与不全等（=== 与 !==），不执行类型转换，直接比较，===类型不一致返回 false，!==类型不一致返回 true，类型一致再比较值。

#### 条件操作符（三元运算符）

```
variable = boolean_expression ? true_value : false_value;
```

#### 赋值操作符=，把右侧的值赋给左侧的变量

#### 逗号操作符

1. 在一条语句中执行多个操作，例如声明多个变量。除此之外，逗号操作符还可以用于赋值此时逗号操作符总会返回表达式中的最后一项

```
var num = (5, 1, 4, 8, 0); // num 的值为 0
```

### 语句

#### if 语句

1. 语法

```
if (condition){ statement1} else {statement2}
```

#### do-while 语句

1. 语法

```
do {
 statement
} while (expression);
```

2. 常用于循环体中的代码至少要被执行一次的情形。

#### while 语句

```
while(expression) statement
```

#### for 语句

1. 语法

```
for (initialization; expression; post-loop-expression) {statement}
```

2. for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部省略，就会创建一个无限循环

#### for-in 语句

1. 它是一种精准的迭代语句，可以用来枚举对象的属性，无序输出

```
for (property in expression) {statement}

//举例，显示了 BOM 中 window 对象的所有属性
for (var propName in window) {
 document.write(propName);
}
```

2. 要迭代的对象的变量值为 null 或 undefined，es 会不执行循环体

#### label 语句（？）

1. 语法

```
label: statement
//举例
start: for (var i=0; i < count; i++) {
 alert(i);
}
```

2. 作用，在代码中添加标签，以便将来使用
3. 加标签的语句一般都要与 for 语句等循环语句配合使用。

#### break 和 continue 语句

1. break 和 continue 语句用于在循环中精确地控制代码的执行
2. 区别：
   - break 语句会立即退出循环，强制继续执行循环后面的语句
   - 而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行
3. break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下

#### with 语句

1. 作用：将代码的作用域设置到一个特定的对象中
2. 语法：

```
with (expression) statement;

/*举例，上面的代码可以改写成下面的，在 with 语句的代码块
内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询
location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。*/
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;

with(location){
 var qs = search.substring(1);
 var hostName = hostname;
 var url = href;
}
```

3. 严格模式下不允许使用 with 语句，否则将视为语法错误。不建议使用 with 语句

#### switch 语句

1. 语法

```
switch (expression) {
case value:
 statement
 break;
case value:
 statement
 break;


case value:
 statement
 break;
case value:
 statement
 break;
default:
statement
}
```

2. 可以在 switch 语句中使用任何数据类型
3. 每个 case 的值不一定是常量，可以是变量，甚至是表达式
4. switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换

### 函数

#### 基本知识

1. 语法

```
function functionName(arg0, arg1,...,argN) {
 statements
}
```

2. 函数默认没有返回值，只有以通过 return 语句后跟要返回的值来实现返回值，注意执行完 return 语句之后停止并立即退出。因此，函数体内位于 return 语句之后的任何代码都永远不会执行。

#### 参数

1. ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型，
   - 原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）
   - 在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。例如

```
function sayHi() {
 alert("Hello " + arguments[0] + "," + arguments[1]);
}
```

#### 没有重载

如果在 ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数

## 变量、作用域、内存

### 基本类型和引用类型的值

1. 基本信息

- 基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。
- 引用类型的值是保存在内存中的对象，js 不允许直接操作对象的内存空间，所以操作对象实际上是在操作对象的引用。当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象

2. 特点

- 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
- 引用类型的值是对象，保存在堆内存中；包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；

#### 动态的属性

只能给引用类型值动态添加属性

#### 复制变量值

1. 基本类型：如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。这两个变量可以参与任何操作而不会相互影响
2. 引用类型：当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中，但这个值的副本是一个针指向存储在堆中的一个对象指针，复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。

#### 传递参数

1. es 中所有函数的参数都是按值传递的，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样

- 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素）
- 在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部

```
/*示例1，参数是按值传递的，obj 按引用来访问同一个对象，当在函数内部为 obj 添加 name
属性后，函数外部的 person 也将有所反映*/
function setName(obj) {
 obj.name = "Nicholas";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"

/*示例2，参数是按值传递的，即使在函数内部修改了参数的值，但原始的引用仍然保持未变
实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。 */
function setName(obj) {
 obj.name = "Nicholas";
 obj = new Object();
 obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"
```

2. 把 ECMAScript 函数的参数想象成局部变量。局部对象会在函数执行完毕后立即被销毁

#### 检测类型

1. 检测基本数据类型用 typeof，如果变量的值是一个对象或 null，则 typeof 返回"object"
2. 检测引用类型的值用 instanceof，原理是根据它的原型链来识别

```
//语法
result = variable instanceof constructor
```

- 检测一个引用类型值和 Object 构造函数时，instanceof 始终会返回 true
- 检测基本类型的值，则该操作符始终会返回 false，因为基本类型不是对象
- 注意跨域无法使用，（要确认一下）

### 执行环境和作用域

1. 执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。
2. 执行环境有全局执行环境（也称为全局环境）和函数执行环境

- 全局执行环境是最外围的一个执行环境，在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的
- 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
- 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；

3. 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁，全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁
4. 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。
5. 当代码在一个环境中执行时，会创建变量对象的一个作用域链，它保证对执行环境有权访问的所有变量和函数的有序访问。

- 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数
- 每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

#### 延长作用域链

1. 方法：在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。

- try-catch 语句的 catch 块；创建一个新的变量对象，其中包含的是被抛出的错误对象的声明
- with 语句。将指定的对象添加到作用域链中

#### 没有块级作用域

1. 声明变量，使用 var 声明的变量会自动被添加到最接近的环境中。

- 在函数内部，最接近的环境就是函数的局部环境；
- 在 with 语句中，最接近的环境是函数环境。
- 如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。

2. 查询标识符，搜索过程从作用域链的前端（当前执行环境）开始，向上逐级查询与给定名字匹配的标识符

- 如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符

### 垃圾收集

1. JavaScript 具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。
2. 原理：按照固定的时间间隔找出那些不再继续使用的变量，然后释放其占用的内存。
3. 函数中局部变量的正常生命周期：只在函数执行的过程中存在
4. 标识无用变量的策略：标记清除和引用计数

#### 标记清除

1. 运行机制：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

#### 引用计数

1. 运行机制：跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存
2. 存在问题：循环引用，如果两个对象发生了循环引用，那么它们的引用次数永远不会是 0，如果被重复多次调用，就会导致大量内存得不到回收

```
/*举例：变量 myObject 有一个名为 element 的属性指向 element 对象；而变量 element 也有
一个属性名叫 someObject 回指 myObject。由于存在这个循环引用，即使将例子中的 DOM 从页面中
移除，它也永远不会被回收。*/
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.element = element;
element.someObject = myObject;

//解决方法：不使用它们的时候手工断开连接
myObject.element = null;
element.someObject = null;
```

#### 性能问题：

动态确定垃圾收集的时间间隔

#### 管理内存

1. 分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃
2. 优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用

- 解除引用适用于大多数全局变量和全局对象的属性，
- 局部变量会在它们离开执行环境时自动被解除引用
- 解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收

## 引用类型

### object 类型

#### 创建实例的方式

1. 使用 new 操作符后跟 Object 构造函数

```
var person = new Object();
person.name = "Nicholas";
person.age = 29;
```

2. 使用对象字面量表示法，通过对象字面量定义对象时，不会调用 Object 构造函数

```
var person = {
 name : "Nicholas",


 age : 29
};

//使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象
var person = {}; //与 new Object()相同
```

- 对象字面量也是向函数传递大量可选参数的首选方式

```
/*示例：这种传递参数的模式最适合需要向函数传入大量可选参数的情形*/
function displayInfo(args) {
 var output = "";
 if (typeof args.name == "string"){
 output += "Name: " + args.name + "\n";
 }
 if (typeof args.age == "number") {
 output += "Age: " + args.age + "\n";
 }
 alert(output);
}
displayInfo({
 name: "Nicholas",
 age: 29
});
displayInfo({
 name: "Greg"
});
```

#### 访问对象属性方法：点表示法和方括号表示法

1 使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中，优点是

- 可以通过变量来访问属性

```
alert(person["name"]); //"Nicholas"
alert(person.name); //"Nicholas"
```

- 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法

```
person["first name"] = "Nicholas";
```

### array 类型

#### 基础

1. 创建数组的基本方法

- 使用 Array 构造函数 + 可以给构造函数传递道数组要保存的项目数量 + 可以向 Array 构造函数传递数组中应该包含的项 + 给构造函数传递一个值，传递的是数值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值的只有一项的数组 + 使用 Array 构造函数时也可以省略 new 操作符

```
var colors = new Array();
var colors = new Array(20);
var colors = new Array("red", "blue", "green");
```

- 使用数组字面量表示法,数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开,在使用数组字面量表示法时，也不会调用 Array 构造函数

```
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
var names = []; // 创建一个空数组
```

2. 特点

- 数组的每一项可以保存任何类型的数据
- 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据

3. 索引

- 方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值，索引超过了数组现有项数，数组就会自动增加长度
- 索引数字基于 0 开始

4. 数组的 length 属性，设置这个属性，可以从数组的末尾移除项或向数组中添加新项

#### 检测数组

1. 对于一个网页，或者一个全局作用域而言，使用 instanceof 操作符就可以判断
2. 如果网页中包含多个框架或多个全局执行环境，需要使用了 Array.isArray()方法，这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的

```
if (Array.isArray(value)){
 //对数组执行某些操作
}
```

#### 转换方法

1. 调用数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串
2. 调用 valueOf()返回的还是数组
3. 调用数组的 toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符串
4. 使用 join()方法，则可以使用不同的分隔符来构建上述三个方法返回的字符串

- join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。

```
var colors = ["red", "green", "blue"];
alert(colors.join("||")); //red||green||blue
```

5. 如果数组中的某一项的值是 null 或者 undefined，那么该值在 join()、toLocaleString()、toString()和 valueOf()方法返回的结果中以空字符串表示。

#### 栈方法

1. 栈是一种 LIFO（Last-In-First-Out，后进先出）的数据结构，也就是最新添加的项最早被移除，而栈中项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置——栈的顶部。类似喝水的杯子
2. push()和 pop()方法

- push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度
- pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项

#### 队列方法

1. 队列数据结构的访问规则是 FIFO（First-In-First-Out，先进先出）。队列在列表的末端添加项，从列表的前端移除项。类似于一条单向的管道
2. shift()，它能够移除数组中的第一个项并返回该项，同时将数组长度减 1。

- 结合使用 shift()和 push()方法，可以像使用队列一样使用数组。

3. unshift()，在数组前端添加任意个项并返回新数组的长度

- 使用 unshift()和 pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项

#### 重排序方法

1. reverse()和 sort()

- reverse()方法会反转数组项的顺序
- 默认情况下，sort()方法按升序排列数组项，特别地，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。 + 比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数 + 对于数值类型或者其 valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可

```
function compare(value1, value2){
 return value2 - value1;
}
```

#### 操作方法

1. concat()方法可以基于当前数组中的所有项创建一个新数组

- 没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本
- 传递给 concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中
- 传递的值不是数组，这些值就会被简单地添加到结果数组的末尾

2. slice()，基于当前数组中的一或多个项创建一个新数组，接受一或两个参数，即要返回项的起始和结束位置，含头不含尾

- 只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项
- 有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项
- slice()方法不会影响原始数组

3. splice()的主要用途是向数组的中部插入项，返回一个数组，该数组中包含从原始数组中删除的项

- 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。
- 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,"red","green")会从当前数组的位置 2 开始插入字符串"red"和"green"。
- 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,"red","green")会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串"red"和"green"。

#### 位置方法

1. indexOf()：

- 接收两个参数：要查找的项和（可选的）表示查找起点位置的索引
- 法从数组的开头（位置 0）开始向后查找
- 返回要查找的项在数组中的位置，没找到的情况下返回-1
- 查找的项必须严格相等

2. lastIndexOf()

- 接收两个参数：要查找的项和（可选的）表示查找起点位置的索引
- 从数组的末尾开始向前查找。
- 返回要查找的项在数组中的位置，没找到的情况下返回-1
- 查找的项必须严格相等

#### 迭代方法

es5 中数组有 5 个迭代方法，每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象，函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身

1. every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。
2. filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。
3. forEach()：对数组中的每一项运行给定函数。这个方法没有返回值
4. map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组
5. some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。

```
var numbers = [1,2,3,4,5,4,3,2,1];
var everyResult = numbers.every(function(item, index, array){
 return (item > 2);
});

alert(everyResult); //false

var someResult = numbers.some(function(item, index, array){
 return (item > 2);
});

alert(someResult); //true
```

#### 归并方法

reduce()和 reduceRight()，这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值，函数接收 4 个参数：前一个值、当前值、项的索引和数组对象

1. reduce()方法从数组的第一项开始，逐个遍历到最后
2. reduceRight()则从数组的最后一项开始，向前遍历到第一项。

```
//使用 reduce()方法可以执行求数组中所有值之和的操作，比如：
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array){
 return prev + cur;
});
alert(sum); //15
```

### Date 类型

1. 创建日期对象

```
var now = new Date();
```

- 调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间
- 创建特定的日期和时间的日期对象，必须传入表示该日期的毫秒数（即从 UTC 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数）。es 提供了两个方法：Date.parse()和 Date.UTC()。 + Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数,如果这个字符串不能表示日期，则返回 NaN.直接将表示日期的字符串传递给 Date 构造函数，也会在后台调用 Date.parse() + Date.UTC()方法同样也返回表示日期的毫秒数，。Date.UTC()的参数分别是年份、基于 0 的月份（一月是 0，二月是 1，以此类推）、月中的哪一天（1 到 31）、小时数（0 到 23）、分钟、秒以及毫秒数，只有前两个参数是必须的

2. ECMAScript 5 添加了 Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数，支持该方法的浏览器从 ie9 开始，兼容的方法是使用+操作符把 Data 对象转换成字符串

```
var start = Date.now();
//调用函数
doSomething();
//取得停止时间
var stop = Date.now(),
 result = stop – start;

 //与上面的等价
 //取得开始时间
 var start = +new Date();
 //调用函数
 doSomething();
 //取得停止时间
 var stop = +new Date(),
  result = stop - start;
```

#### 继承的方法

1. Date 类型的 toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间
2. toString()方法则通常返回带有时区信息的日期和时间
3. valueOf()方法，返回日期的毫秒表示

#### 日期格式化方法

1. toDateString()——以特定于实现的格式显示星期几、月、日和年；
2. toTimeString()——以特定于实现的格式显示时、分、秒和时区；
3. toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
4. toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
5. toUTCString()——以特定于实现的格式完整的 UTC 日期。

#### 日期/时间组件方法

getXXXX()，setXXXX,直接取得和设置日期值中特定部分的方法，具体查表，列举几个

1. getTime() 返回表示日期的毫秒数；与 valueOf()方法返回的值相同
2. setTime(毫秒) 以毫秒数设置日期，会改变整个日期
3. getFullYear() 取得 4 位数的年份（如 2007 而非仅 07）
4. setFullYear(年) 设置日期的年份。传入的年份值必须是 4 位数字（如 2007 而非仅 07）
5. getMonth() 返回日期中的月份，其中 0 表示一月，11 表示十二月
6. setMonth(月) 设置日期的月份。传入的月份值必须大于 0，超过 11 则增加年份

### RegExp 类型，用以支持正则

1. 以字面量形式来定义的正则表达式

- 语法

```
var expression = / pattern / flags ;
```

- 模式（pattern）部分可以是任何简单或复杂的正则表达式 + 模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：( [ { \ ^ $ | ) ? * + .]}

```
/*
* 匹配第一个" [bc]at"，不区分大小写
*/
var pattern2 = /\[bc\]at/i;
```

- 每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为,标志有： + g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止； + i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写 + m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

```
//示例
/*
* 匹配字符串中所有"at"的实例
*/
var pattern1 = /at/g;
/*
* 匹配第一个"bat"或"cat"，不区分大小写
*/
var pattern2 = /[bc]at/i;
/*
* 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写
*/
var pattern3 = /.at/gi;
```

2. 使用 RegExp 构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串

```
//示例
var pattern2 = new RegExp("[bc]at", "i");
```

- 由于 RegExp 构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义，比如元字符和那些已经转义过的字符，例如/\[bc\]at/ 对应着"\\[bc\\]at"

#### RegExp 实例属性，没什么用

1. global：布尔值，表示是否设置了 g 标志。
2. ignoreCase：布尔值，表示是否设置了 i 标志。
3. lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。
4. multiline：布尔值，表示是否设置了 m 标志。
5. source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回

#### RegExp 实例方法

1. exec()，该方法是专门为捕获组而设计

```
var text = "mom and dad and baby";
var pattern = /mom( and dad( and baby)?)?/gi; //包含两个捕获组。

var matches = pattern.exec(text);
alert(matches.index); // 0
alert(matches.input); // "mom and dad and baby"
alert(matches[0]); // "mom and dad and baby"  与整个模式匹配的字符串
alert(matches[1]); // " and dad and baby"  与模式中的第一个捕获组匹配的字符串
alert(matches[2]); // " and baby"  与模式中的第二个捕获组匹配的字符串
```

- exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null。
- 返回的数组包含两个额外的属性：index 和 input。 + index 表示匹配项在字符串中的位置， + input 表示应用正则表达式的字符串。
- 在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串
- 不设置全局标志的情况下，在同一个字符串上多次调用 exec()将始终返回第一个匹配项的信息
- 设置全局标志的情况下，每次调用 exec()则都会在字符串中继续查找新匹配项

2. test()，接受一个字符串参数，在模式与该参数匹配的情况下返回 true；否则，返回 fals

```
//示例
var text = "000-00-0000";
var pattern = /\d{3}-\d{2}-\d{4}/;
if (pattern.test(text)){
 alert("The pattern was matched.");
}
```

#### RegExp 构造函数属性，看起来没什么用

#### 模式的局限性，es 不支持某些高级正则特性,例如向后查找，原子集，并集与交集类等

### function 类型

1. 函数实际上是对象，每个函数都是 Function 类型的实例，与其他引用类型一样具有属性和方法，此函数名实际上也是一个指向函数对象的指针
2. 函数的定义方式

- 使用函数声明语法

```
function sum (num1, num2) {
 return num1 + num2;
}
```

- 使用函数表达式

```
var sum = function(num1, num2){
 return num1 + num2;
}; //注意末尾处的分号
```

- 使用 Function 构造函数,但是不推荐使用,因为会引起二次解析影响性能

```
var sum = new Function("num1", "num2", "return num1 + num2");
```

#### 函数没有重载，只有覆盖

声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数

#### 函数声明和函数表达式

1. 解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）即函数声明提升；对于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行，所以如果在函数表达式之前就调用该函数会报错。
2. 除了上面这一点，函数声明与函数表达式的语法其实是等价的

#### 作为值的函数

1. 函数可以作为值来使用，即不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回
2. 示例

```
function createComparisonFunction(propertyName) {
 return function(object1, object2){
 var value1 = object1[propertyName];
 var value2 = object2[propertyName];
 if (value1 < value2){
 return -1;
 } else if (value1 > value2){
 return 1;
 } else {
 return 0;
 }
 };
}

var data = [{name: "Zachary", age: 28}, {name: "Nicholas", age: 29}];
data.sort(createComparisonFunction("name"));
alert(data[0].name); //Nicholas
```

#### 函数内部属性

函数内部有两个特殊的对象：arguments 和 this。

1. arguments 是一个类数组对象，包含着传入函数中的所有参数，它的主要用途是保存函数参数

- 它有个叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。

```
//一个经典的定义阶乘函数
function factorial(num){
 if (num <=1) {
 return 1;
 } else {
 return num * factorial(num-1)
 // return num * arguments.callee(num-1)    这样可以消除函数执行和函数名的耦合
 }
}
```

2. this 引用的是函数据以执行的环境对象，谁调用它，它就指向谁

- 当在网页的全局作用域中调用函数时，this 对象引用的就是 window

3. 函数对象的属性：callee。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null

#### 函数属性和方法

1. length 属性表示函数希望接收的命名参数的个数
2. prototype 属性，prototype 是保存引用类型所有实例方法的真正所在，诸如 toString()和 valueOf()等方法实际上都保存在 prototype 名下，prototype 属性是不可枚举的
3. apply()方法用途是在特定的作用域中调用函数，接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象
4. call()方法用途是在特定的作用域中调用函数，接收两个参数：：第一个参数是 this 值没有变化，第二个参数必须逐个列举出来
5. apply()和 call()真正的用处是能够扩充函数作用域，并且函数对象不需要与方法有任何耦合关系

```
window.color = "red";
var o = { color: "blue" };
function sayColor(){
 alert(this.color);
}
sayColor(); //red
sayColor.call(this); //red
sayColor.call(window); //red
sayColor.call(o); //blue
```

6. bind()方法会创建一个函数的实例，其 this 值会被绑定到传给 bind()函数的值

### 基本包装类型：Boolean、Number 和 String

1. 每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据
2. 引用类型与基本包装类型的主要区别就是对象的生存期。

- 使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中
- 自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。不能在运行时为基本类型值添加属性和方法

3. Object 构造函数可以根据传入值的类型返回相应基本包装类型的实例。
4. 使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。当使用 typeof 测试时，前者返回一个 object，后者是对应的基本数据类型

#### Boolean 类型，不建议使用 Boolean 对象

1. 创建 Boolean 对象，可以调用 Boolean 构造函数并传入 true 或 false 值。

```
var booleanObject = new Boolean(true);
```

2. Boolean 类型的实例重写了 valueOf()方法，返回基本类型值 true 或 false；重写了 toString()方法，返回字符串"true"和"false"。
3. 存在问题：布尔表达式中的所有对象都会被转换为 true， Boolean 类型的实例在布尔表达式中也永远代表的是 true
4. 基本类型与引用类型的布尔值的两个区别

- typeof 操作符对基本类型返回"boolean"，而对引用类型返回"object"
- 使用 instanceof 操作符测试 Boolean 对象会返回 true，而测试基本类型的布尔值则返回 false。

#### Number 类型，不建议直接实例化 Number 类型

1. 创建 Number 对象，可以在调用 Number 构造函数时向其中传递相应的数值

```
var numberObject = new Number(10);
```

2. Number 类型也重写了 valueOf()、toLocaleString()和 toString()方法。

- 重写后的 valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值
- 可以为 toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式

3. Number 类型还提供了用于将数值格式化为字符串的方法。

- toFixed()方法会按照指定的小数位返回数值的字符串表示，接收一个参数指定输出结果中的小数位数，如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入，适合处理货币值
- toExponential()，该方法返回以指数表示法（也称 e 表示法）表示的数值的字符串形式。接收一个参数指定输出结果中的小数位数
- toPrecision()方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式，接收一个参数，即表示数值的所有数字的位数（不包括指数部分），toPrecision()会根据要处理的数值决定到底是调用 toFixed()还是调用 toExponential()。

#### String 类型

1. 使用 String 构造函数来创建对象。

```
var stringObject = new String("hello world");
```

2. length 属性，表示字符串中包含多个字符
3. 字符方法 charAt()和 charCodeAt()用于访问字符串中特定字符,都接收一个参数，即基于 0 的字符位置

- charAt()方法以单字符字符串的形式返回给定位置的那个字符
- charCodeAt()以字符编码的形式返回给定位置的那个字符

4.  字符串操作方法

- concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串,实践中使用更多的还是加号操作符（+）
- 基于子字符串创建新字符串的方法 slice()、substr()和 substring()。都返回被操作字符串的一个子字符串，而且也都接受一或两个参数 + 第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束 + 它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响 + 参数是负值 + slice()方法会将传入的负值与字符串的长度相加 + substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为 0 + substring()方法会把所有负值参数都转换为 0

5. 字符串位置方法

- 从字符串中查找子字符串的方法：indexOf()和 lastIndexOf()，返回子字符串的位置（如果没有找到该子字符串，则返回-1）。 + indexOf()方法从字符串的开头向后搜索子字符串， + lastIndexOf()方法是从字符串的末尾向前搜索子字符串
- 这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索

6.  trim()方法

- 这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果

7. 字符串大小写转换方法

- 涉及字符串大小写转换的方法有 4 个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和 toLocaleUpperCase()。前两个通用，后两个是针对特定地区的实现

8. 字符串的模式匹配方法

- match()，在字符串上调用这个方法，本质上与调用 RegExp 的 exec()方法相同，只接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象
- search()，它的参数与 match()方法的参数相同，search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1，而且，search()方法始终是从字符串开头向后查找模式
- replace()方法，它接受两个参数：第一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志

```
var text = "cat, bat, sat, fat";
var result = text.replace("at", "ond");
alert(result); //"cond, bat, sat, fat"

result = text.replace(/at/g, "ond");
alert(result); //"cond, bond, sond, fond"
```

- split()，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中,分隔符可以是字符串，也可以是一个 RegExp 对象.split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小

9. localeCompare()方法,比较两个字符串，并返回下列值中的一个：

- 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；
- 如果字符串等于字符串参数，则返回 0
- 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1，具体的值同样要视实现而定）

10. fromCharCode()方法,是静态方法，是接收一或多个字符编码，然后将它们转换成一个字符串

### 单体内置对象

#### Global 对象

1. 不属于任何其他对象的属性和方法，最终都是它的属性和方法
2. 事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性，诸如 isNaN()、isFinite()、parseInt()以及 parseFloat()
3. Global 对象的其他方法：

- URI 编码方法，Global 对象的 encodeURI()和 encodeURIComponent()方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。
- eval()方法，超强大的方法，它只接受一个参数，即要执行的 ECMAScript（或 JavaScript）字符串 + 当解析器发现代码中调用 eval()方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析，然后把执行结果插入到原位置。 + 通过 eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过 eval()执行的代码可以引用在包含环境中定义的变量 + eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在 eval()执行的时候创建。 + 它的危险，可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）

4.  Global 对象的属性

- 特殊的值 undefined、NaN 以及 Infinity 都是 Global 对象的属性
- 所有原生引用类型的构造函数，像 Object 和 Function，也都是 Global 对象的属性

5. window 对象

- 在全局作用域中声明的所有变量和函数，就都成为了 window 对象的属性

#### Math 对象

1. Math 对象的属性，一般为一些特殊值，例如 π 的值，10 的自然对数等等
2. min()和 max()方法，用于确定一组数值中的最小值和最大值，可以接收任意多个数值参数
3. 舍入方法，Math.ceil()、Math.floor()和 Math.round()。

- Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；
- Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；
- Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数

4. random()方法，返回大于等于 0 小于 1 的一个随机数

## 面向对象

### 理解对象

1. 对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数”，相当于说对象是一组没有特定顺序的值，可以对象想象成散列表
2. 每个对象都是基于一个引用类型创建的，这个引用类型可以是第 5 章讨论的原生类型，也可以是开发人员定义的类型。

#### 属性类型：数据属性和访问器属性

1. 数据属性：包含一个数据值的位置。在这个位置可以读取和写入值，

- 属性有 4 个特性 + [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，直接在对象上定义的属性的这个特性默认值为 true。把 configurable 设置为 false，表示不能从对象中删除属性。一旦把属性定义为不可配置的，就不能再把它变回可配置 + [[Enumerable]]：表示能否通过 for-in 循环返回属性，直接在对象上定义的属性的这个特性默认值为 true。 + [[Writable]]：表示能否修改属性的值，直接在对象上定义的属性的这个特性默认值为 true。 + [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为 undefined
- Object.defineProperty()方法可以修改属性默认的特性，接收三个参数：属性所在的对象、属性的名字和一个描述符对象。描述符对象的属性必须是：configurable、enumerable、writable 和 value。在调用 Object.defineProperty()方法时，如果不指定，configurable、enumerable 和 writable 特性的默认值都是 false。注意这个方法 ie8+才能实现

```
var person = {};
Object.defineProperty(person, "name", {
 writable: false,
 value: "Nicholas"
});
alert(person.name); //"Nicholas"
person.name = "Greg";
alert(person.name); //"Nicholas"
```

2. 访问器属性

- 不包含数据值；包含一对儿 getter 和 setter 函数
- 4 个特性 + [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。  
   + [[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为 true。  
   + [[Get]]：在读取属性时调用的函数。默认值为 undefined。  
   + [[Set]]：在写入属性时调用的函数。默认值为 undefined。
- 访问器属性不能直接定义，必须使用 Object.defineProperty()来定义，注意这个方法 ie9+才能实现

```
var book = {
 _year: 2004,
 edition: 1
};
Object.defineProperty(book, "year", {
 get: function(){
 return this._year;
 },
 set: function(newValue){
 if (newValue > 2004) {
 this._year = newValue;
 this.edition += newValue - 2004;
 }
 }
});
book.year = 2005;
alert(book.edition); //2
```

- 使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化，如上例

#### 定义多个属性

1. Object.defineProperties()方法可以通过描述符一次定义多个属性。接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应.ie9+支持该方法

```
var book = {};
Object.defineProperties(book, {
	 _year: {
		 value: 2004
	},
	edition: {
		 value: 1
	},
	 year: {
		 get: function(){
		return this._year;
	},
	set: function(newValue){
		 if (newValue > 2004) {
		 this._year = newValue;
		 this.edition += newValue - 2004;
		 }
	}
}
});
```

#### 读取属性的特性

1. Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。

### 创建对象

#### 工厂模式

1. 封装以特定接口创建对象

- 在函数内 new 一个对象，设置该对象的属性，返回该对象

```
function createPerson(name, age, job){
 var o = new Object();
 o.name = name;
 o.age = age;
 o.job = job;
 o.sayName = function(){
 alert(this.name);
 };
 return o;
}

var person1 = createPerson("Nicholas", 29, "Software Engineer");
```

2. 存在问题：没有解决对象识别的问题（即怎样知道一个对象的类型）

#### 构造函数模式

1. 创建自定义的构造函数，从而定义自定义对象类型的属性和方法

```
function Person(name, age, job){
 this.name = name;
 this.age = age;
 this.job = job;
 this.sayName = function(){
 alert(this.name);
 };
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
```

2. 与工厂模式区别

- 没有显式地创建对象
- 直接将属性和方法赋给了 this 对象
- 没有 return 语句
- 构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头
- 创建 Person 的新实例，必须使用 new 操作符
- 可以用 instanceof 检测对象类型

3. 使用 new 操作符调用构造函数经历的步骤

- 创建一个新对象；
- 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；
- 执行构造函数中的代码（为这个新对象添加属性）；
- 返回新对象

4. 创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型
5. 任何函数，通过 new 操作符来调用，那它就可以作为构造函数，如果不通过 new 操作符来调用，就是普通函数
6. 不使用 new 操作符调用构造函数，：属性和方法都被添加给 window 对象，因为在全局作用域中调用一个函数时，this 对象总是指向 Global 对象
7. 构造函数模式的缺点：每个方法都要在每个实例上重新创建一遍，针对这个问题可以将构造函数内的方法转移到构造函数外部以实现全局共享，但是这样带来一个新问题：如果对象需要定义很多方法，那么就要定义很多个全局函数，自定义的引用类型就丝毫没有封装性了

#### 原型模式

1. 每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向函数的原型对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。
2. prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中

```
/*构造函数变成了空函数。也可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法*/
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
 alert(this.name);
};
var person1 = new Person();
person1.sayName(); //"Nicholas"
var person2 = new Person();
person2.sayName(); //"Nicholas"
alert(person1.sayName == person2.sayName); //true
```

3. 理解原型对象

- 创建一个新函数，就会为该函数创建一个 prototype 属性，这个属性指向函数的原型对象.在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针.例如 Person.prototype. constructor 指向 Person
- 连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间
- ![原型与构造函数](JavaScript高级程序设计_files/1.jpg)

```
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
 alert(this.name);
};
var person1 = new Person();
person1.sayName(); //"Nicholas"
var person2 = new Person();
person2.sayName(); //"Nicholas"
alert(person1.sayName == person2.sayName); //true
/*
Person.prototype 指向了原型对象，而 Person.prototype.constructor 又指回了 Person。
原型对象中除了包含 constructor 属性之外，还包括后来添加的其他属性。Person 的每个实例——
person1 和 person2 都包含一个内部属性，该属性仅仅指向了 Person.prototype；换句话说，它们
与构造函数没有直接的关系
*/
```

- 在所有实现中都无法访问到实例中的[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之间是否存在这种关系

```
alert(Person.prototype.isPrototypeOf(person1)); //true
```

- ES 5 增加 Object.getPrototypeOf()方法，在所有支持的实现中，这个方法返回[[Prototype]]的值，即地取得一个对象的原型

```
alert(Object.getPrototypeOf(person1) == Person.prototype); //true
alert(Object.getPrototypeOf(person1).name); //"Nicholas"
```

- 对象的属性搜索流程：先搜索对象实例，再搜索指针指向的原型对象
- 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。注意，使用 delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性
- hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中，它只在给定属性存在于对象实例中时才会返回 true，存在原型中返回 false

4. 原型与 in 操作符

- 两种方式使用 in 操作符 + 单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中 + 使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。

```
alert("name" in person1); //true
```

- 默认不可枚举的所有属性和方法，包括：hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和 valueOf()。
- ES5 的 Object.keys()方法可以取得对象上所有可枚举的实例属性，。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组
- 使用 Object.getOwnPropertyNames()方法可以得到所有实例属性，无论它是否可枚举

5. 更简单的原型语法

- 用一个包含所有属性和方法的对象字面量来重写整个原型对象

```
/* 注意，下例中constructor 属性不再指向 Person，因为下例中的prototype对象是默认的object对象的，用这个方法创建的对象无法通过constructor确定对象的类型，/
function Person(){
}
Person.prototype = {
/* constructor : Person,  如果需要constructor 属性指向 Person也可以自己设置，不设置通过constructor确定对象的类型，注意默认constructor属性是不可枚举的，这样设置后的[[Enumerable]]特性被设置为 true，需要将[[Enumerable]]特性被设置为 false，则通过defineProperty()**/
 name : "Nicholas",
 age : 29,
 job: "Software Engineer",
 sayName : function () {
 alert(this.name);
 }
};
```

6. 原型的动态性
   用字面量重写原型后，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；实例引用的仍然是最初的原型。如果把实例放到重写原型后再创建，则联系的是重写后的原型
   ![](JavaScript高级程序设计_files/实例与原型关系.jpg)
7. 原生对象的原型
   js 原生的引用类型都是采用原型模式创建的，通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法.注意！不推荐修改原生对象的原型

```
String.prototype.startsWith = function (text) {
 return this.indexOf(text) == 0;
};
var msg = "Hello world!";
alert(msg.startsWith("Hello")); //true
```

8. 原型对象的问题

- 省略了为构造函数传递初始化参数这一环节，导致所有实例在默认情况下都将取得相同的属性值
- 原型中所有属性是被很多实例共享的，但是，实例一般都是要有属于自己的全部属性的

#### 组合使用构造函数模式和原型模式,定义引用类型的一种默认模式

1. 构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性.

```
function Person(name, age, job){
 this.name = name;
 this.age = age;
 this.job = job;
 this.friends = ["Shelby", "Court"];
}
Person.prototype = {
 constructor : Person,
 sayName : function(){
 alert(this.name);
 }
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
person1.friends.push("Van");
alert(person1.friends); //"Shelby,Count,Van"
alert(person2.friends); //"Shelby,Count"
alert(person1.friends === person2.friends); //false
alert(person1.sayName === person2.sayName); //true
```

#### 动态原型模式

动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。

```
function Person(name, age, job){
 //属性
 this.name = name;
 this.age = age;
 this.job = job;
  //方法
  if (typeof this.sayName != "function"){
  Person.prototype.sayName = function(){
  alert(this.name);
  };
  }
 }
 var friend = new Person("Nicholas", 29, "Software Engineer");
 friend.sayName();
```

- 使用动态原型模式时，不能使用对象字面量重写原型,因为在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系

#### 寄生构造函数模式

1. 基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。
2. 除了使用 new 操作符来创建实例并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的

```
function Person(name, age, job){
 var o = new Object();
 o.name = name;
 o.age = age;
 o.job = job;
 o.sayName = function(){
 alert(this.name);
 };
 return o;
}
var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName(); //"Nicholas"
```

3. 返回的对象与构造函数或者与构造函数的原型属性之间没有关系，所以无法用 instanceof 操作符来确定对象类型
4. 不推荐使用这种方式

#### 稳妥构造函数模式

1. 稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象，适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup 程序）改动时使用
2. 稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用 this；二是不使用 new 操作符调用构造函数

```
function Person(name, age, job){
 //创建要返回的对象
 var o = new Object();
 //可以在这里定义私有变量和函数
  //添加方法
  o.sayName = function(){
  alert(name);
  };
  //返回对象
  return o;
 }
 var friend = Person("Nicholas", 29, "Software Engineer");
 friend.sayName(); //"Nicholas"
```

3. 返回的对象与构造函数或者与构造函数的原型属性之间没有关系，所以无法用 instanceof 操作符来确定对象类型

### 继承

js 只支持依靠原型链实现继承

#### 原型链

1. 基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法
2. 具体做法是构造函数 1 的原型对象 A 将包含一个指向另一个原型 B 的指针，相应地，原型 B 中也包含着一个指向另一个构造函数 2 的指针
3. 示例
   ![](JavaScript高级程序设计_files/原型链.jpg)

```
function SuperType(){
 this.property = true;
}
SuperType.prototype.getSuperValue = function(){
 return this.property;
};
function SubType(){
 this.subproperty = false;
}
//继承了 SuperType ,通过创建 SuperType 的实例，并将该实例赋给SubType.prototype 实现的
SubType.prototype = new SuperType();
SubType.prototype.getSubValue = function (){
 return this.subproperty;
};
var instance = new SubType();
alert(instance.getSuperValue()); //true
```

4. 默认的原型，所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype
5. 判断原型与实例的关系，

- 使用 instanceof 操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true

```
alert(instance instanceof Object); //true
```

- 使用 isPrototypeOf()方法。只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，该方法也会返回 true

```
alert(Object.prototype.isPrototypeOf(instance)); //true
```

6. 谨慎的定义方法，给原型添加方法的代码一定要放在替换原型（实现继承）的语句之后，此外，在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链
7. 原型链的问题：

- 包含引用类型值的原型属性会被所有实例共享
- 在创建子类型的实例时，不能向超类型的构造函数中传递参数

#### 借用构造函数（做伪造对象或经典继承）

基本思想是在子类型构造函数的内部调用超类型构造函数
通过使用 apply()和 call()方法在（将来）新创建的对象上执行构造函数

1. 传递参数

```
function SuperType(){
 this.name = name;
}
function SubType(){
 //继承了 SuperType，同时还传递了参数
 SuperType.call(this, "Nicholas");
 //实例属性
 this.age = 29; //在调用超类型构造函数后，再添加应该在子类型中定义的属性
}
var instance = new SubType();
alert(instance.name); //"Nicholas";
alert(instance.age); //29
```

2. 借用构造函数的问题:无法避免构造函数模式存在的问题——方法都在构造函数中定义,复用性不强

#### 组合继承（伪经典继承），组合原型链和借用构造函数，最常用

思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性

1. 示例

```
//让两个不同的 SubType 实例既分别拥有自己属性——包括 colors 属性，又可以使用相同的方法
function SuperType(name){
 this.name = name;
 this.colors = ["red", "blue", "green"];
}

SuperType.prototype.sayName = function(){
 alert(this.name);
 };

 function SubType(name, age){
  //继承属性,借用构造函数
  SuperType.call(this, name); // 第二次调用 SuperType()
  this.age = age;
 }
 //继承方法。原型链
 SubType.prototype = new SuperType();  //第一次调用 SuperType()
 SubType.prototype.constructor = SubType;
 SubType.prototype.sayAge = function(){
  alert(this.age);
 };

 var instance1 = new SubType("Nicholas", 29);
 instance1.colors.push("black");
 alert(instance1.colors); //"red,blue,green,black"
 instance1.sayName(); //"Nicholas";
 instance1.sayAge(); //29
 var instance2 = new SubType("Greg", 27);
 alert(instance2.colors); //"red,blue,green"
 instance2.sayName(); //"Greg";
 instance2.sayAge(); //27
```

2. 问题
   无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部

#### 原型式继承：

借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型

1. 原型式继承要求必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给 object()函数，然后再根据具体需求对得到的对象加以修改即可

```
function object(o){
 function F(){} //创建一个临时性的构造函数
 F.prototype = o; //将传入的对象作为这个构造函数的原型
 return new F(); //返回临时类型的新实例
}

var person = {
 name: "Nicholas",
 friends: ["Shelby", "Court", "Van"]
};
var anotherPerson = object(person);
anotherPerson.name = "Greg";
```

2. ES5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。

- 在传入一个参数的情况下，Object.create()与 object()方法的行为相同

```
//var anotherPerson = object(person);
var anotherPerson = Object.create(person);
```

- Object.create()方法的第二个参数与 Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的

```
var anotherPerson = Object.create(person, {
name: {
value: "Greg"
}
});
```

3. 此方法 IE9+以上才实现
4. 类似使用原型模式，包含引用类型值的属性始终都会共享相应的值

#### 寄生式继承

寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。

1. 示例

```
function createAnother(original){
 var clone = object(original); /*通过调用函数创建一个新对象，不一定非要用object(),任何能够返回新对象的函数都适用于此模式 */
 clone.sayHi = function(){ //以某种方式来增强这个对象
 alert("hi");
 };
 return clone; //返回这个对象
}

var person = {
 name: "Nicholas",
 friends: ["Shelby", "Court", "Van"]
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi(); //"hi"
```

2. 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率

#### 寄生组合式继承

1. 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法
2. 思路：使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型
3. 示例

```
function inheritPrototype(subType, superType){
 var prototype = object(superType.prototype); //创建对象
 prototype.constructor = subType; //增强对象
 subType.prototype = prototype; //指定对象
}
function SuperType(name){
 this.name = name;
 this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
 alert(this.name);
};
function SubType(name, age){
 SuperType.call(this, name);
 this.age = age;
}
inheritPrototype(SubType, SuperType);
SubType.prototype.sayAge = function(){
 alert(this.age);
};


```

4. 优点：它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType. prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf()

## 函数表达式

1. 定义函数的两种方式

- 函数声明

```
function functionName(arg0, arg1, arg2) {
 //函数体
}
```

函数声明提升，执行代码之前会先读取函数声明。所以可以把函数声明放在调用它的语句后面。

- 函数表达式

```
var functionName = function(arg0, arg1, arg2){
 //函数体
};
```

- 这种方式创建的是匿名函数，因为 function 关键字后面没有标识符。
- 函数表达式创建的函数不存在函数提升，调用必须放在后面

### 递归：函数通过名字调用自身

1. 直接用函数名实现递归存在隐患

```
//一个经典的阶乘函数，arguments.callee 是一个指向正在执行的函数的指针
function factorial(num){
 if (num <= 1){
 return 1;
 } else {
 return num * factorial(num-1); //改为return num * arguments.callee(num-1);就不会报错了
 }
}
var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4)); //出错！
```

2. 在严格模式下，访问这个 arguments.callee 属性会导致错误，所以可以通过命名函数表达式来实现效果

```
var factorial = (function f(num){
 if (num <= 1){
 return 1;
 } else {
return num * f(num-1);
 }
});//将函数放f()用括号括起来是为了让解析器清楚这是一个表达式
```

### 闭包

1. 闭包是指有权访问另一个函数作用域中的变量的函数
2. 创建闭包的常见方式，就是在一个函数内部创建另一个函数
3. 外部函数在执行完毕后，其活动对象也不会被销毁，因为它返回的匿名函数的作用域链仍然在引用这个活动对象。直到匿名函数被销毁后，外部函数的活动对象才会被销毁
4. ![](JavaScript高级程序设计_files/闭包.jpg)
5. 过度使用闭包可能会导致内存占用过多

#### 闭包与变量

1. 闭包只能取得包含函数中任何变量的最后一个值

```
//第一个函数中，在每个函数内部 i 的值都是 10
function createFunctions(){
 var result = new Array();
 for (var i=0; i < 10; i++){
 result[i] = function(){
 return i;
 };
 }
 return result;
}
//每个函数就会返回各自不同的索引值
 var result = new Array();
 for (var i=0; i < 10; i++){
 result[i] = function(num){
 return function(){
 return num;
 };
 }(i);
 }
 return result;
}
```

#### this 对象

1. 在全局函数中，this 等于 window，而当函数被作为某个对象的方法调用时，this 等于那个对象，
2. 匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window，如果通过 call()或 apply()改变函数执行环境的情况下，this 就会指向其他对象
3. 每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量

```
var name = "The Window";
var object = {
 name : "My Object",
 getNameFunc : function(){
 return function(){
 return this.name;
 };
 }
};
alert(object.getNameFunc()()); //"The Window"（在非严格模式下）
```

4. 把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象

```
var name = "The Window";
var object = {
 name : "My Object",
 getNameFunc : function(){
var that = this;
 return function(){
 return that.name;
 };
 }
};
alert(object.getNameFunc()()); //"My Object"
```

5. 特殊情况下，this 的值可能发生改变

```
var name = "The Window";
var object = {
 name : "My Object",
getName: function(){
return this.name;
}
};

object.getName(); //"My Object"
(object.getName)(); //"My Object"
(object.getName = object.getName)(); //"The Window"，在非严格模式下
/*最后一行相当于 var temp = object.getName = object.getName; temp(); 这样调用this当然是 window */
```

#### 内存泄漏

1. 如果闭包的作用域链中保存着一个 HTML 元素，那么就意味着该元素将无法被销毁
2. 必要把引用变量设置为 null，解除对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。

### 模仿块级作用域

1. 匿名函数可以用来模仿块级作用域

```
/*将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式，如果没有括号就会出错。而紧随其后的另一对圆括号会立即调用这个函数*/
(function(){
 //这里是块级作用域
})();
```

2. 注意：JavaScript 将 function 关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式，只要给它加上一对圆括号
3. 无论在什么地方，只要临时需要一些变量，就可以使用私有作用域

```
function outputNumbers(count){
 (function () {
 for (var i=0; i < count; i++){  //这个你们匿名函数是一个闭包，所以可以可以访问外部作用域的count变量
 alert(i);
 }
 })(); //此时已经将循环插入私有作用域内，外部不能访问
 alert(i); //导致一个错误！
}
```

4. 用处：在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数
5. 优点：可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链

### 私有变量

1. 任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数
2. 有权访问私有变量和私有函数的公有方法称为特权方法

- 在构造函数中定义特权方法,缺点是必须使用构造函数模式来达到这个目的

```
function MyObject(){
 //私有变量和私有函数
 var privateVariable = 10;
 function privateFunction(){
 return false;
 }
 //特权方法,作为闭包有权访问在构造函数中定义的所有变量和函数
 this.publicMethod = function (){
 privateVariable++;
 return privateFunction();
 };
}
```

#### 静态私有变量

1. 基本模式:创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法,公有方法是在原型上定义的

- 注意：在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数
- 没有在声明 MyObject 时使用 var 关键字，使他成为一个全局变量
- 与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的

```
(function(){
 //私有变量和私有函数
 var privateVariable = 10;
 function privateFunction(){
 return false;
 }
 //构造函数
 MyObject = function(){
 };
 //公有/特权方法
 MyObject.prototype.publicMethod = function(){
 privateVariable++;
 return privateFunction();
 };
})();
```

#### 模块模式

1. 模块模式是为单例创建私有变量和特权方法
2. 单例（singleton），指的就是只有一个实例的对象，一般 js 按对象字面量来创建单例对象

```
var singleton = {
 name : value,
 method : function () {
 //这里是方法的代码
 }
};
```

3. 模块模式语法

- 使用了一个返回对象的匿名函数
- 将一个对象字面量作为函数的值返回,里面只包含可以公开的属性和方法
- 对象字面量定义的是单例的公共接口

```
var singleton = function(){
 //私有变量和私有函数
 var privateVariable = 10;
 function privateFunction(){
 return false;
 }
 //特权/公有方法和属性
  return {
  publicProperty: true,
  publicMethod : function(){
  privateVariable++;
  return privateFunction();
  }
  };
 }();
```

4. 使用场景：必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，如 Web 应用程序中，经常需要使用一个单例来管理应用程序级的信息

#### 增强的模块模式：返回对象之前加入对其增强的代码

1. 增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况
2. 示例

```
var singleton = function(){
 //私有变量和私有函数
 var privateVariable = 10;
 function privateFunction(){
 return false;
 }
 //创建对象
 var object = new CustomType();
 //添加特权/公有属性和方法
 object.publicProperty = true;
 object.publicMethod = function(){
 privateVariable++;
 return privateFunction();
 };
 //返回这个对象
 return object;
}();
```

## BOM

### window 对象

在浏览器中，window 对象有双重角色，它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象

#### 全局作用域

1. 在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法
2. 定义全局变量与在 window 对象上直接定义属性的差别：全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以

#### 窗口关系和框架

1. 如果页面中包含框架，则每个框架都拥有自己的 window 对象，并且保存在 frames 集合中
2. 在 frames 集合中，可以通过数值索引（从 0 开始，从左至右，从上到下）或者框架名称来访问相应的 window 对象。每个 window 对象都有一个 name 属性，其中包含框架的名称
3. window 对象的框架属性

- top 对象始终指向最高（最外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。例如 top.frames[0]
- parent（父）对象始终指向当前框架的直接上层框架。在某些情况下，parent 有可能等于 top；但在没有框架的情况下，parent 一定等于 top（此时它们都等于 window）
- self 对象，它始终指向 window；实际上，self 和 window 对象可以互换使用

4. 在使用框架的情况下，浏览器中会存在多个 Global 对象。在每个框架中定义的全局变量会自动成为框架中 window 对象的属性
5. 跨框架传递的对象使用 instanceof 操作符有影响

#### 窗口位置

1. 使用 moveTo()和 moveBy()方法是有可能将窗口精确地移动到一个新位置，这两个方法都接收两个参数，其中 moveTo()接收的是新位置的 x 和 y 坐标值，而 moveBy()接收的是在水平和垂直方向上移动的像素数
2. 注意在 Opera 和 IE 7（及更高版本）中默认就是禁用的。另外，这两个方法都不适用于框架，只能对最外层的 window 对象使用。

#### 窗口大小

1. 不同浏览器，不同版本取得窗口大小的方法不一样
2. 使用 resizeTo()和 resizeBy()方法可以调整浏览器窗口的大小。这两个方法都接收两个参数，其中 resizeTo()接收浏览器窗口的新宽度和新高度，而 resizeBy()接收新窗口与原窗口的宽度和高度之差
3. 注意：在 Opera 和 IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的 window 对象使用。

#### 导航与打开窗口

1. window.open()方法既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口。这个方法可以接收 4 个参数，通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用.该方法会返回一个指向新窗口的引用，通过这个引用可以对新窗口进行调整

- 要加载的 URL、
- 窗口目标，可以是\_self、\_parent、\_top 或\_blank，或者已有窗口或框架的名称，
- 一个特性字符串，![](JavaScript高级程序设计_files/6.jpg)
- 一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。
  举例

```
window.open("http://www.wrox.com/","wroxWindow",
 "height=400,width=400,top=10,left=10,resizable=yes");
 /*这行代码会打开一个新的可以调整大小的窗口，窗口初始大小为 400×400 像素，并且距屏幕上沿
和左边各 10 像素。*/
```

2. 对于浏览器的主窗口，如果没有得到用户的允许是不能关闭它的。不过，弹出窗口倒是可以调用 top.close()在不经用户允许的情况下关闭自己，弹出窗口关闭之后，窗口的引用仍然还在
3. 新创建的 window 对象有一个 opener 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层 window 对象（top）中有定义，而且指向调用 window.open()的窗口或框架。将 opener 属性设置为 null 就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行
4. 安全限制
   不同浏览器限制方法各有不同，一般有不允许在屏幕之外创建弹出窗口、不允许将弹出窗口移动到屏幕以外、不允许关闭状态栏，默认情况下不允许移动弹出窗口或调整其大小
5. 弹出窗口屏蔽程序
   在弹出窗口被屏蔽时，考虑两种情况：

- 如果是浏览器内置的屏蔽程序阻止的弹出窗口，那么 window.open()很可能会返回 null
- 如果是浏览器扩展或其他程序阻止的弹出窗口，那么 window.open()通常会抛出一个错误

```
//检测出弹出窗口是否被屏蔽
var blocked = false;
try {
 var wroxWin = window.open("http://www.wrox.com", "_blank");
 if (wroxWin == null){
 blocked = true;
 }
} catch (ex){
 blocked = true;
}
if (blocked){
 alert("The popup was blocked!");
}
```

#### 间歇调用和超时调用

1. 超时调用需要使用 window 对象的 setTimeout()方法，在指定的时间过后执行代码，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）

- 第一个参数可以是一个包含 JavaScript 代码的字符串（不建议使用），也可以是一个函数
- 第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行，因为 js 是单线程的，一定时间只能执行一段代码，代码执行由 js 任务队列管理，这个参数只是告诉 JS 过多久时间将当前任务添加到队列中，如果队列中不是空的，那要等前面的代码执行完成再执行
  调用 setTimeout()之后，该方法会返回一个数值 ID，表示超时调用。这个超时调用 ID 可以用来取消超时调用

2. 要取消尚未执行的超时调用计划，可以调用 clearTimeout()方法并将相应的超时调用 ID 作为参数传递给它

```
//设置超时调用
var timeoutId = setTimeout(function() {
 alert("Hello world!");
}, 1000);
//注意：把它取消
clearTimeout(timeoutId);
```

3. setInterval()间歇调用，按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒），参数与 setTimeOut 相同

```
var num = 0;
var max = 10;
var intervalId = null;
function incrementNumber() {
 num++;
 //如果执行次数达到了 max 设定的值，则取消后续尚未执行的调用
 if (num == max) {
 clearInterval(intervalId);
 alert("Done");
 }
}
intervalId = setInterval(incrementNumber, 500);
```

调用 setInterval()方法同样也会返回一个间歇调用 ID，该 ID 可用于在将来某个时刻取消间歇调用
如果不取消间歇调用，间歇调用将会一直执行到页面卸载

4. 取消尚未执行的间歇调用，可以使用 clearInterval()方法并传入相应的间歇调用 ID
5. 使用超时调用来模拟间歇调用,最好不要使用间歇调用,因为后一个间歇调用可能会在前一个间歇调用结束之前启动

```
var num = 0;
var max = 10;
function incrementNumber() {
 num++;
 //如果执行次数未达到 max 设定的值，则设置另一次超时调用
 if (num < max) {
 setTimeout(incrementNumber, 500);
 } else {
 alert("Done");
 }
}
setTimeout(incrementNumber, 500);
```

#### 系统对话框

alert()、confirm()和 prompt()方法，系统对话框与在浏览器中显示的网页没有关系，也不包含 HTML。它们的外观由操作系统及（或）浏览器设置决定，而不是由 CSS 决定

1. alert()方法，这个方法接受一个字符串并给用户显示一个系统对话框，其中包含指定的文本和一个 OK（“确定”）按钮
2. confirm()方法，显示的对话框除了显示 OK 按钮外，还会显示一个 Cancel（“取消”）按钮，两个按钮可以让用户决定是否执行给定的操作

- confirm()方法返回的布尔值：true 表示单击了 OK，false 表示单击了 Cancel 或单击了右上角的 X 按钮

```
if (confirm("Are you sure?")) {
 alert("I'm so glad you're sure! ");
} else {
 alert("I'm sorry to hear you're not sure. ");
}
```

3. 用 prompt()方法,个“提示”框，用于提示用户输入一些文本。提示框中除了显示 OK 和 Cancel 按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。

- 如果用户单击了 OK 按钮，则 prompt()返回文本输入域的值；如果用户单击了 Cancel 或没有单击 OK 而是通过其他方式关闭了对话框，则该方法返回 null。

### location 对象

1. location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是 document 对象的属性；换句话说，window.location 和 document.location 引用的是同一个对象
2. location 对象的用处不只表现在它保存着当前文档的信息，还表现在它将 URL 解析为独立的片段，让开发人员可以通过不同的属性访问这些片段
3. location 对象的属性，![](JavaScript高级程序设计_files/7.jpg)

#### 查询字符串参数

1. 访问 URL 包含的查询字符串的属性并不方便，可以创建一个函数，用以解析查询字符串，然后返回包含所有参数的一个对象

```
function getQueryStringArgs(){
 //取得查询字符串并去掉开头的问号
 var qs = (location.search.length > 0 ? location.search.substring(1) : ""),
 //保存数据的对象
 args = {},
 //取得每一项
 items = qs.length ? qs.split("&") : [],
 item = null,
 name = null,
 value = null,
  //在 for 循环中使用
  i = 0,
  len = items.length;
  //逐个将每一项添加到 args 对象中
  for (i=0; i < len; i++){
  item = items[i].split("=");
  name = decodeURIComponent(item[0]);
  value = decodeURIComponent(item[1]);
  if (name.length) {
  args[name] = value;
  }
  }
  return args;
 }
 //假设查询字符串是?q=javascript&num=10
 var args = getQueryStringArgs();
 alert(args["q"]); //"javascript"
 alert(args["num"]); //"10"
```

#### 位置操作

1. 改变浏览器位置可以使用 assign()方法并为其传递一个 URL

```
location.assign("http://www.wrox.com");
//相当于
window.location = "http://www.wrox.com";
location.href = "http://www.wrox.com";
```

2. 些改变浏览器位置的方法中，最常用的是设置 location.href 属性。
3. 修改 location 对象的其他属性也可以改变当前加载的页面，每次修改 location 的属性（hash 除外），页面都会以新 URL 重新加载。
4. 通过上述任何一种方式修改 URL 之后，浏览器的历史记录中就会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。如果不希望产生新纪录可以使用 replace()方法导航到其他页面
5. reload()，作用是重新加载当前显示的页面。如果调用 reload()时不传递任何参数，页面就会以最有效的方式重新加载，如果传递参数 true，强制从服务器重新加载。位于 reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将 reload()放在代码的最后一行。

```
location.reload(); //重新加载（有可能从缓存中加载）
location.reload(true); //重新加载（从服务器重新加载）
```

### navigator 对象

1. 属性![](JavaScript高级程序设计_files/8.jpg)

#### 检测插件

1. 对于非 IE 浏览器，可以使用 plugins 数组来达到这个目的。该数组中的每一项都包含下列属性

- name：插件的名字。
- description：插件的描述。
- filename：插件的文件名
- length：插件所处理的 MIME 类型数量。

```
//检测插件（在 IE 中无效）
function hasPlugin(name){
 name = name.toLowerCase();
 for (var i=0; i < navigator.plugins.length; i++){
 if (navigator. plugins [i].name.toLowerCase().indexOf(name) > -1){
 return true;
 }
 }
 return false;
}
//检测 Flash
alert(hasPlugin("Flash"));
//检测 QuickTime
alert(hasPlugin("QuickTime"));
```

2. 在 IE 中检测插件的唯一方式就是使用专有的 ActiveXObject 类型，并尝试创建一个特定插件的实例。IE 是以 COM 对象的方式实现插件的，而 COM 对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其 COM 标识符

```
//检测 IE 中的插件
function hasIEPlugin(name){
 try { //创建未知 COM 对象会导致抛出错误
 new ActiveXObject(name);
 return true;
 } catch (ex){
 return false;
 }
}
//检测 Flash
alert(hasIEPlugin("ShockwaveFlash.ShockwaveFlash"));
//检测 QuickTime
alert(hasIEPlugin("QuickTime.QuickTime"));
```

3. 典型的做法是针对每个插件分别创建检测函数

```
//检测所有浏览器中的 Flash
function hasFlash(){
 var result = hasPlugin("Flash");
 if (!result){
 result = hasIEPlugin("ShockwaveFlash.ShockwaveFlash");
 }
  return result;
 }
 //检测 Flash
 alert(hasFlash());
```

#### 注册处理程序

registerContentHandler()和 registerProtocolHandler()方法，这两个方法可以让一个站点指明它可以处理特定类型的信息

1. registerContentHandler()方法接收三个参数：要处理的 MIME 类型（资源的媒体类型）、可以处理该 MIME 类型的页面的 URL 以及应用程序的名称

```
//将一个站点注册为处理 RSS 源的处理程序
navigator.registerContentHandler("application/rss+xml",
 "http://www.somereader.com?feed=%s", "Some Reader");// %s 表示RSS 源 URL
```

2. registerProtocolHandler()方法，它也接收三个参数：要处理的协议（例如，mailto 或 ftp）、处理该协议的页面的 URL 和应用程序的名称

```
// 将一个应用程序注册为默认的邮件客户端
navigator.registerProtocolHandler("mailto",
 "http://www.somemailclient.com?cmd=%s", "Some Mail Client");
```

### screen 对象

1. screen 对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等
2. 每个浏览器中的 screen 对象都包含着各不相同的属性
   ![](JavaScript高级程序设计_files/9.jpg)
   ![](JavaScript高级程序设计_files/10.jpg)

### history 对象

history 是 window 对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的 history 对象与特定的 window 对象关联

1. 用 go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。

- 这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮，0 表示刷新当前页面
- 也可以给 go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做

```
//后退一页
history.go(-1);
//前进两页
history.go(2);
//跳转到最近的 wrox.com 页面
history.go("wrox.com");
```

2. back()和 forward()来代替 go()模仿浏览器的“后退”和“前进”按钮
3. history 对象还有一个 length 属性，保存着历史记录的数量

```
if (history.length == 0){
 //这应该是用户打开窗口后的第一个页面
}
```

## 客户端检测

浏览器之间的差异以及不同浏览器的“怪癖”（quirk），多得简直不胜枚举。因此，客户端检测除了是一种补救措施之外，更是一种行之有效的开发策略。不到万不得已，就不要使用客户端检测，先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案

### 能力检测（特性检测）

1. 能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。采用这种方式不必顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力，就可以给出解决方案
2. 模式

```
if (object.propertyInQuestion){
 //使用 object.propertyInQuestion
}
//示例，IE 的早期版本中确实不存在 document.getElementById()
function getElement(id){
 if (document.getElementById){
 return document.getElementById(id);
 } else if (document.all){
 return document.all[id];
 } else {
  throw new Error("No way to retrieve element!");
  }
 }
```

3. 必须测试实际要用到的特性。一个特性存在，不一定意味着另一个特性也存在

#### 更可靠的能力检测

1. 示例，检测一个对象是否支持排序

```
//不要这样做！这不是能力检测——只检测了是否存在相应的方法
function isSortable(object){
 return !!object.sort;
}
//任何包含 sort属性的对象也会返回 true，上面的方法就检测不出来了
var result = isSortable({ sort: true });
//这样更好：检查 sort 是不是函数
function isSortable(object){
return typeof object.sort == "function";
}
```

2. 在可能的情况下，要尽量使用 typeof 进行能力检测。特别是，宿主对象没有义务让 typeof 返回合理的值，尤其是在 IE 中 typeof 返回的值不一定合理
3. 在浏览器环境下测试任何对象的某个特性是否存在，要使用下面这个函数

```
//作者：Peter Michaux
function isHostMethod(object, property) {
 var t = typeof object[property];
 return t=='function' ||
 (!!(t=='object' && object[property])) ||
 t=='unknown';
}
result = isHostMethod(xhr, "open"); //true

```

#### 能力检测，不是浏览器检测

在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器

### 怪癖检测

目标是识别浏览器的特殊行为，知道浏览器存在什么缺陷 bug

1. 举例

- ，IE8 及更早版本中存在一个 bug，即如果某个实例属性与[[Enumerable]]标记为 false 的某个原型属性同名，那么该实例属性将不会出现在 fon-in 循环当中

```
var hasDontEnumQuirk = function(){
 var o = { toString : function(){} };
 for (var prop in o){
if (prop == "toString"){
 return false;
 }
 }
 return true;
}();
```

2. “怪癖”都是个别浏览器所独有的，而且通常被归为 bug

### 用户代理检测

1. 用户代理检测通过检测用户代理字符串（指明浏览器的名称和版本号）来确定实际使用的浏览器

- 在服务器端，通过检测用户代理字符串来确定用户使用的浏览器是一种常用而且广为接受的做法
- 在客户端，用户代理检测一般被当作一种万不得已才用的做法，其优先级排在能力检测和（或）怪癖检测之后

2. 电子欺骗，就是指浏览器通过在自己的用户代理字符串加入一些错误或误导性信息，来达到欺骗服务器的目的

#### 用户代理字符串的历史，了解就好啦

#### 用户代理字符串检测技术

1. 识别呈现引擎，五大呈现引擎：IE、Gecko、WebKit、KHTML 和 Opera
2. 识别浏览器
3. 识别平台，三大主流平台是 Windows、Mac 和 Unix（包括各种 Linux
4. 识别 Windows 操作系统
5. 识别移动设备
6. 识别游戏系统

#### 完整的代码。略过，想知道自己看书去 P260

#### 使用方法

用户代理检测一般适用于下列情形

- 不能直接准确地使用能力检测或怪癖检测
- 同一款浏览器在不同平台下具备不同的能力。
- 为了跟踪分析等目的需要知道确切的浏览器。

## DOM

DOM(文档对象模型）是针对 HTML 和 XML 文档的一个 API（应用程序编程接口）

### 节点层次

1. 文档元素，文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。

- 在 HTML 页面中，文档元素始终都是<html>元素。
- 在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素

2. HTML 中的标记可以通过节点来表示： HTML 元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示

#### Node 类型

1. 除了 IE 之外，在其他所有浏览器中都可以访问到 Node 类型；
2. 每个节点都有一个 nodeType 属性，用于表明节点的类型，共有 12 种，都有一个数字常量来表示
3. 为了确保跨浏览器兼容，最好还是将 nodeType 属性与数字值进行比较

```
if (someNode.nodeType == 1){ //适用于所有浏览器
 alert("Node is an element.");
}
```

5. nodeName 和 nodeValue 属性
   要了解节点的具体信息，可以使用 nodeName 和 nodeValue 这两个属性。这两个属性的值完全取决于节点的类型,最好先检测一下

```
if (someNode.nodeType == 1){
 value = someNode.nodeName; //nodeName 的值是元素的标签名
}
```

6. 节点关系，类似家谱

- 每个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。NodeList 是一种类数组对象（注意不是 Array 的实例），用于保存一组有序的节点，可以通过位置来访问这些节点 + NodeList 对象的实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 NodeList 对象中 + 访问保存在 NodeList 中的节点可以通过角标或使用 item()方法 + 注意 length 属性表示的是访问 NodeList 的那一刻，其中包含的节点数量

```
	var firstChild = someNode.childNodes[0];
	var secondChild = someNode.childNodes.item(1);
	var count = someNode.childNodes.length;
```

    + ，对 NodeList 对象使用 Array.prototype.slice()方法可以将其转换为数组

```
	//在 IE8 及之前版本中无效,因为那时NodeList实现为为一个 COM 对象
	var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);
	//在所有浏览器中都可以运行的版本
	function convertToArray(nodes){
	 var array = null;
	 try {
	 array = Array.prototype.slice.call(nodes, 0); //针对非 IE 浏览器
	 } catch (ex) {
	 array = new Array();
	 for (var i=0, len=nodes.length; i < len; i++){
	 array.push(nodes[i]);
	 }
	 }
	 return array;
	}
```

- 每个节点都有一个 parentNode 属性，该属性指向文档树中的父节点 + 通过使用在 childNodes 列表中每个节点的 previousSibling 和 nextSibling 属性，可以访问同一列表中的其他节点，。列表中第一个节点的 previousSibling 属性值为 null，而列表中最后一个节点的 nextSibling 属性的值同样也为 null，可以通过这个特性判断是不是第一个或者最后一个孩子 + 父节点的 firstChild 和 lastChild 属性分别指向其 childNodes 列表中的第一个和最后一个节点 + someNode.firstChild 的值始终等于 someNode.childNodes[0] ， 而 someNode.lastChild 的值始终等于 someNode. childNodes [someNode.childNodes.length-1]。
- ownerDocument，该属性指向表示整个文档的顶端文档节点

7. 操作节点

- appendChild()，用于向 childNodes 列表的末尾添加一个节点，返回值是新增的节点
- insertBefore()方法可以把节点放在 childNodes 列表中某个特定的位置上。返回值是被插入的节点，这个方法接受两个参数：要插入的节点和作为参照的节点。如果参照节点是 null，则 insertBefore()与 appendChild()执行相同的操作
- replaceChild()方法替换节点（移除要替换的节点并且同时由要插入的节点占据其位置），返回要替换的节点，接受的两个参数是：要插入的节点和要替换的节点
- removeChild()移除节点，这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值
- 注意：使用这几个方法必须先取得父节点（使用 parentNode 属性），在不支持子节点的节点上调用了这些方法会报错

8. 其他方法

- 所有类型的节点都具备的方法 + cloneNode()，用于创建调用这个方法的节点的一个完全相同的副本，cloneNode()方法接受一个布尔值参数，表示是否执行深复制。 + 在参数为 true 的情况下，执行深复制，也就是复制节点及其整个子节点树； + 在参数为 false 的情况下，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，这个节点副本就成为了一个“孤儿”，除非通过 appendChild()、insertBefore()或 replaceChild()将它添加到文档 + cloneNode()方法不会复制添加到 DOM 节点中的 JavaScript 属性，例如事件处理程序等
- normalize()作用是处理文档树中的文本节点，找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点

#### Document 类型

1. 在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面，，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构
2. Document 节点具有下列特征

- nodeType 的值为 9；
- nodeName 的值为"#document"；
- nodeValue 的值为 null；
- parentNode 的值为 null；
- ownerDocument 的值为 null
- 其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。

3. 文档的子节点

- 两个内置的访问其子节点的快捷方式 + documentElement 属性，该属性始终指向 HTML 页面中的<html>元素，这个更快更直接 + 通过 childNodes 列表访问文档元素
- document 对象还有一个 body 属性，直接指向<body>元素

```
var body = document.body; //取得对<body>的引用
```

- Document 另一个可能的子节点是 DocumentType,通常将<!DOCTYPE>标签看成一个与文档其他部分不同的实体，可以通过 doctype 属性（在浏览器中是 document.doctype）来访问它的信息,浏览器对 document.doctype 的支持差别很大,![](JavaScript高级程序设计_files/11.jpg)

3. 文档信息

- document 对象还有一些标准的 Document 对象所没有的属性 + title，包含着<title>元素中的文本——显示在浏览器窗口的标题栏或标签页上 + URL 属性中包含页面完整的 URL（即地址栏中显示的 URL） + domain 属性中只包含页面的域名。可设置，但是有限制，只能设为 URL 中包含的域 + referrer 属性中则保存着链接到当前页面的那个页面的 URL

4. 查找元素

- getElementById()，接收一个参数：要取得的元素的 ID，。如果找到相应的元素则返回该元素，如果不存在带有相应 ID 的元素，则返回 null + 如果页面中多个元素的 ID 值相同，getElementById()只返回文档中第一次出现的元素 + 。IE7 及较低版本还为此方法添加了一个有意思的“怪癖”：name 特性与给定 ID 匹配的表单元素（<input>、<textarea>、<button>及<select>）也会被该方法返回
- getElementsByTagName()，接受一个参数，即要取得元素的标签名，而返回的是包含零或多个元素的 NodeList，。 + 在 HTML 文档中，这个方法会返回一个 HTMLCollection 对象，作为一个“动态”集合，可以使用方括号语法或 item()方法来访问 HTMLCollection 对象中的项。而这个对象中元素的数量则可以通过其 length 属性取得。 + HTMLCollection 对象还有一个方法，叫做 namedItem()，使用这个方法可以通过元素的 name 特性取得集合中的项 + HTMLCollection 还支持按名称访问项,对命名的项也可以使用方括号语法来访问 + 对 HTMLCollection 而言，我们可以向方括号中传入数值或字符串形式的索引值。在后台，对数值索引就会调用 item()，而对字符串索引就会调用 namedItem()

```
var images = document.getElementsByTagName("img");
var myImage = images.namedItem("myImage");
var myImage = images["myImage"];
```

- getElementsByName()返回带有给定 name 特性的所有元素 HTMLCollectioin,一般用于取得单选按钮；为了确保发送给浏览器的值正确无误，所有单选按钮必须具有相同的 name 特性。

5. 特殊集合
   这些集合都是 HTMLCollection 对象，为访问文档常用的部分提供了快捷方式，包括：

- document.anchors，包含文档中所有带 name 特性的<a>元素；
- document.applets，包含文档中所有的<applet>元素，因为不再推荐使用<applet>元素，所以这个集合已经不建议使用了；
- document.forms，包含文档中所有的<form>元素，与 document.getElementsByTagName("form")得到的结果相同；
- document.images，包含文档中所有的<img>元素，与 document.getElementsByTagName ("img")得到的结果相同；
- document.links，包含文档中所有带 href 特性的<a>元素。

6. DOM 一致性检测
   document.implementation 属性可以检测浏览器实现了 DOM 的哪些部分，它规定了 hasFeature()方法，这个方法接受两个参数：要检测的 DOM 功能的名称及版本号。如果浏览器支持给定名称和版本的功能，则该
   方法返回 true,不过这个方法也有缺陷，返回 true 有时候也不意味着实现与规范一致

```
var hasXmlDom = document.implementation.hasFeature("XML", "1.0");
```

7. 文档写入
   write()、writeln()、open()和 close()

- write()和 writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。 + write()会原样写入 + writeln()则会在字符串的末尾添加一个换行符（\n） + 注意参数中不能直接包含字符串"</script>"，需要加入转义字符\，因为这会导致该字符串被解释为脚本块的结束，它后面的代码将无法执行。
- 方法 open()和 close()分别用于打开和关闭网页的输出流。如果是在页面加载期间使用 write()或 writeln()方法，则不需要用到这两个方法。

#### Element 类型

1. Element 类型用于表现 XML 或 HTML 元素，提供了对元素标签名、子节点及特性的访问，Element 节点具有以下特征

- nodeType 的值为 1；
- nodeName 的值为元素的标签名；
- nodeValue 的值为 null；
- parentNode 可能是 Document 或 Element；
- 其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。

2. 要访问元素的标签名，可以使用 nodeName 属性，也可以使用 tagName 属性；这两个属性会返回相同的值，但是后者更清晰
3. HTML 元素

- 所有 HTML 元素都由 HTMLElement 类型表示，HTMLElement 类型直接继承自 Element 并添加了一些属性： + id，元素在文档中的唯一标识符。 + title，有关元素的附加说明信息，一般通过工具提示条显示出来 + lang，元素内容的语言代码，很少使用 + dir，语言的方向，值为"ltr"（left-to-right，从左至右）或"rtl"（right-to-left，从右至左），也很少使用。 + className，与元素的 class 特性对应，即为元素指定的 CSS 类。没有将这个属性命名为 class，是因为 class 是 ECMAScript 的保留字

```
var div = document.getElementById("myDiv");
alert(div.id);//myDiv
```

4. 取得特性,推荐通过属性来取得和设置特性
   操作特性的 DOM 方法主要有三个，分别是 getAttribute()、setAttribute()和 removeAttribute()

- getAttribute()

```
//这样为 DOM 元素添加一个自定义的属性，该属性不会自动成为元素的特性
div.mycolor = "red";
alert(div.getAttribute("mycolor")); //null（IE 除外）
```

- setAttribute()，这个方法接受两个参数：要设置的特性名和值。如果特性已经存在，setAttribute()会以指定的值替换现有的值；如果特性不存在，setAttribute()则创建该属性并设置相应的值

5. attributes 属性

- Element 类型是使用 attributes 属性的唯一一个 DOM 节点类型。attributes 属性中包含一个 NamedNodeMap，是一个“动态”的集合。元素的每一个特性都由一个 Attr 节点表示，每个节点都保存在 NamedNodeMap 对象中。NamedNodeMap 对象拥有下列方法： + getNamedItem(name)：返回 nodeName 属性等于 name 的节点； + removeNamedItem(name)：从列表中移除 nodeName 属性等于 name 的节点； + setNamedItem(node)：向列表中添加节点，以节点的 nodeName 属性为索引； + item(pos)：返回位于数字 pos 位置处的节点。
- attributes 属性中包含一系列节点，每个节点的 nodeName 就是特性的名称，而节点的 nodeValue 就是特性的值

```
//取得元素的 id 特性的两种写法
var id = element.attributes.getNamedItem("id").nodeValue;

var id = element.attributes["id"].nodeValue;
```

- 使用 attributes 属性遍历元素的特性，

```
//迭代元素的每一个特性，然后将它们构造成 name="value" name="value"
function outputAttributes(element){
 var pairs = new Array(),
 attrName,
 attrValue,
 i,
 len;
 for (i=0, len=element.attributes.length; i < len; i++){
 attrName = element.attributes[i].nodeName;
 attrValue = element.attributes[i].nodeValue;
 pairs.push(attrName + "=\"" + attrValue + "\"");
 }
 return pairs.join(" ");
}
```

6. 创建元素

- document.createElement()方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名
- 使用 createElement()方法创建新元素的同时，也为新元素设置了 ownerDocuemnt 属性。此时，还可以操作元素的特性，为它添加更多子节点，以及执行其他操作
- 新建的元素要添加到文档树中，可以使用 appendChild()、insertBefore()或 replaceChild()方法
- 在 IE7 及更早版本中动态创建元素的某些问题，这些问题可以通过在 createElement()中指定完整的 HTML 标签来解决 + 不能设置动态创建的<iframe>元素的 name 特性。 + 不能通过表单的 reset()方法重设动态创建的<input>元素 + 动态创建的 type 特性值为"reset"的<buttou>元素重设不了表单。 + 动态创建的一批 name 相同的单选按钮彼此毫无关系。name 值相同的一组单选按钮本来应该用于表示同一选项的不同值，但动态创建的一批这种单选按钮之间却没有这种关系。

```
//只在需要避开 IE 及更早版本中上述某个问题的情况下使用,别的浏览器不用
if (client.browser.ie && client.browser.ie <=7){
 //创建一个带 name 特性的 iframe 元素
 var iframe = document.createElement("<iframe name=\"myframe\"></iframe>");
 //创建 input 元素
 var input = document.createElement("<input type=\"checkbox\">");
 //创建 button 元素
 var button = document.createElement("<button type=\"reset\"></button>");
 //创建单选按钮
 var radio1 = document.createElement("<input type=\"radio\" name=\"choice\" "＋
"value=\"1\">");
 var radio2 = document.createElement("<input type=\"radio\" name=\"choice\" "＋
"value=\"2\">");
}
```

7. 元素的子节点
   注意在 IE 和其他浏览器中对子节点的认定不一致，IE 不识别文本节点作为子节点，如果文档里将元素间的空白符删除，那么所有浏览器都会返回相同数目的子节点。

#### Text 类型

1. 文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的 HTML 字符，但不能包含 HTML 代码
2. Text 节点具有以下特征：

- nodeType 的值为 3；
- nodeName 的值为"#text"；
- nodeValue 的值为节点所包含的文本；
- parentNode 是一个 Element；
- 不支持（没有）子节点。可以通过 nodeValue 属性或 data 属性访问 Text 节点中包含的文本，这两个属性中包含的值相同。对 nodeValue 的修改也会通过 data 反映出来，反之亦然。

3. 使用下列方法可以操作节点中的文本。

- appendData(text)：将 text 添加到节点的末尾。
- deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符。
- insertData(offset, text)：在 offset 指定的位置插入 text。 
- replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset+ count 为止处的文本。
- splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点。
- substringData(offset, count)：提取从 offset 指定的位置开始到 offset+count 为止处的字符串。

4. 文本节点还有一个 length 属性，保存着节点中字符的数目。而且，nodeValue.length 和 data.length 中也保存着同样的值。
5. 默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在

```
<!-- 没有内容，也就没有文本节点 -->
<div></div>
<!-- 有空格，因而有一个文本节点 -->
<div> </div>
```

6. 创建文本节点

- document.createTextNode()创建新文本节点，这个方法接受一个参数——要插入节点中的文本
- 创建新文本节点的同时，也会为其设置 ownerDocument 属性，新建的元素要添加到文档树中，可以使用 appendChild()、insertBefore()或 replaceChild()方法

```
var element = document.createElement("div");
element.className = "message";
var textNode = document.createTextNode("Hello world!");
element.appendChild(textNode);
document.body.appendChild(element);
```

7. 规范化文本节点
   normalize()能够将相邻文本节点合并。如果在一个包含两个或多个文本节点的父元素上调用 normalize()方法，则会将所有文本节点合并成一个节点，结果节点的 nodeValue 等于将合并前每个文本节点的 nodeValue 值拼接起来的值
8. 分割文本节点
   splitText()。这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割 nodeValue 值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的 parentNode 相同

#### Comment 类型

1. 注释在 DOM 中是通过 Comment 类型来表示的。Comment 节点具有下列特征：

- nodeType 的值为 8；
- nodeName 的值为"#comment"；
- nodeValue 的值是注释的内容；
- parentNode 可能是 Document 或 Element；
- 不支持（没有）子节点

2. Comment 类型与 Text 类型继承自相同的基类，因此它拥有除 splitText()之外的所有字符串操作方法。与 Text 类型相似，也可以通过 nodeValue 或 data 属性来取得注释的内容。

#### CDATASection 类型,一看就不重要

1. CDATASection 类型只针对基于 XML 的文档，表示的是 CDATA 区域。与 Comment 类似，CDATASection 类型继承自 Text 类型，因此拥有除 splitText()之外的所有字符串操作方法。
2. CDATASection 节点具有下列特征：

- nodeType 的值为 4；
- nodeName 的值为"#cdata-section"；
- nodeValue 的值是 CDATA 区域中的内容；
- parentNode 可能是 Document 或 Element；
- 不支持（没有）子节点。

#### DocumentType 类型

1. DocumentType 类型包含着与文档的 doctype 有关的所有信息，不常用
2. 特征

- nodeType 的值为 10；
- nodeName 的值为 doctype 的名称；
- nodeValue 的值为 null；
- parentNode 是 Document；
- 不支持（没有）子节点。

#### DocumentFragment 类型

1. DOM 规定文档片段（document fragment）是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。
2. DocumentFragment 节点具有下列特征

- nodeType 的值为 11；
- nodeName 的值为"#document-fragment"；
- nodeValue 的值为 null；
- parentNode 的值为 null；
- 子节点可以是 Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference。

#### Attr 类型，很少用

1. 元素的特性在 DOM 中以 Attr 类型来表示，从技术角度讲，特性就是存在于元素的 attributes 属性中的节点。
2. 特性节点具有下列特征：

- nodeType 的值为 2；
- nodeName 的值是特性的名称；
- nodeValue 的值是特性的值；
- parentNode 的值为 null；
- 在 HTML 中不支持（没有）子节点；
- 在 XML 中子节点可以是 Text 或 EntityReference。

3. Attr 对象有 3 个属性：name、value 和 specified（布尔值）

### DOM 操作技术

#### 动态脚本

1. 动态脚本，指的是在页面加载时不存在，但将来的某一时刻通过修改 DOM 动态添加的脚本
2. 创建方式：插入外部文件和直接插入 JavaScript 代码。

```
//第一种方式
function loadScript(url){
 var script = document.createElement("script");
 script.type = "text/javascript";
 script.src = url;
 document.body.appendChild(script);
}
//第二种方式
function loadScriptString(code){
 var script = document.createElement("script");
 script.type = "text/javascript";
 try {
 script.appendChild(document.createTextNode(code));
 } catch (ex){
 /* 这是为了兼容ie，IE对 <script>类节点，不允许访问其子节点 */
 script.text = code;
 }
 document.body.appendChild(script);
}

```

#### 动态样式

1. 动态样式是指在页面刚加载时不存在的样式；动态样式是在页面加载完成后动态添加到页面中的
2. 创建方式

- 利用 dom 操作：添加外部文件

```
//<link>元素添加到<head>元素里
function loadStyles(url){
 var link = document.createElement("link");
 link.rel = "stylesheet";
  link.type = "text/css";
  link.href = url;
  var head = document.getElementsByTagName("head")[0];
  head.appendChild(link);
 }
```

- 通过 dom 操作：通过<style>元素来包含嵌入式 CSS

```
function loadStyleString(css){
 var style = document.createElement("style");
  style.type = "text/css";
  try{
  style.appendChild(document.createTextNode(css));
  } catch (ex){
	  /* 这是为了兼容ie，IE 将<style>视为一个特殊的、与<script>类似的节点，不允许访问其子节点
解决 IE 中这个问题的办法，就是访问元素的 styleSheet 属性，该属性又有一个 cssText 属性，可以接受CSS 代码*/
  style.styleSheet.cssText = css;
  }
  var head = document.getElementsByTagName("head")[0];
  head.appendChild(style);
 }
```

#### 操作表格

1. 使用原始的 DOM 方法创建表格，要写很多行
2. 为了方便，HTML DOM 还为<table>、<tbody>和<tr>元素添加了一些属性和方法如下
   ![](JavaScript高级程序设计_files/12.jpg)
   ![](JavaScript高级程序设计_files/13.jpg)

```
//创建 table
var table = document.createElement("table");
table.border = 1;
table.width = "100%";
//创建 tbody
var tbody = document.createElement("tbody");
table.appendChild(tbody);
//创建第一行
tbody.insertRow(0);
tbody.rows[0].insertCell(0);
tbody.rows[0].cells[0].appendChild(document.createTextNode("Cell 1,1"));
tbody.rows[0].insertCell(1);
tbody.rows[0].cells[1].appendChild(document.createTextNode("Cell 2,1"));
//创建第二行
tbody.insertRow(1);
tbody.rows[1].insertCell(0);
tbody.rows[1].cells[0].appendChild(document.createTextNode("Cell 1,2"));
tbody.rows[1].insertCell(1);
tbody.rows[1].cells[1].appendChild(document.createTextNode("Cell 2,2"));
//将表格添加到文档主体中
document.body.appendChild(table);
```

#### 使用 NodeList

1. NodeList ,NamedNodeMap 和 HTMLCollection 这三个集合都是“动态的”,每当文档结构发生变化时，它们都会得到更新,所有 NodeList 对象都是在访问 DOM 文档时实时运行的查询
2. 如果想要迭代一个 NodeList，最好是使用 length 属性初始化第二个变量，然后将迭代器与该变量进行比较

```
var divs = document.getElementsByTagName("div"),
 i,
 len,
 div;
for (i=0, len=divs.length; i < len; i++){
 div = document.createElement("div");
 document.body.appendChild(div);
}
```

3. 应该尽量减少访问 NodeList 的次数。因为每次访问 NodeList，都会运行一次基于文档的查询。所以，可以考虑将从 NodeList 中取得的值缓存起来。

## DOM 扩展

DOM 的两个主要的扩展是 Selectors API（选择符 API）和 HTML5

### 选择符 API

Selectors API Level 1 的核心是两个方法：querySelector()和 querySelectorAll()。

#### querySelector()方法

1. querySelector()方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回 null。
2. 通过 Document 类型调用 querySelector()方法时，会在文档元素的范围内查找匹配的元素。而通过 Element 类型调用 querySelector()方法时，只会在该元素后代元素的范围内查找匹配的元素。

#### querySelectorAll()方法

1. querySelectorAll()方法接收的参数与是一个 CSS 选择符，但返回的是一个 NodeList 的实例。
2. 能够调用 querySelectorAll()方法的类型包括 Document、DocumentFragment 和 Element
3. 要取得返回的 NodeList 中的每一个元素，可以使用 item()方法，也可以使用方括号语法

```
//取得所有<p>元素中的所有<strong>元素
var strongs = document.querySelectorAll("p strong");
var i, len, strong;
for (i=0, len=strongs.length; i < len; i++){
 strong = strongs[i]; //或者 strongs.item(i)
 strong.className = "important";
}
```

#### matchesSelector()方法，浏览器不实现该方法

### 元素遍历

1. Element Traversal API 为 DOM 元素添加了以下 5 个属性。

- childElementCount：返回子元素（不包括文本节点和注释）的个数。
- firstElementChild：指向第一个子元素；firstChild 的元素版。
- lastElementChild：指向最后一个子元素；lastChild 的元素版。
- previousElementSibling：指向前一个同辈元素；previousSibling 的元素版。
- nextElementSibling：指向后一个同辈元素；nextSibling 的元素版。

2. 示例

```
//跨浏览器遍历某元素的所有子元素
var i,
 len,
 child = element.firstChild;
while(child != element.lastChild){
 if (child.nodeType == 1){ //检查是不是元素
 processChild(child);
 }
 child = child.nextSibling;
}
//使用 Element Traversal 新增的元素
var i,
 len,
 child = element.firstElementChild;
while(child != element.lastElementChild){
 processChild(child); //已知其是元素
 child = child.nextElementSibling;
}
```

### HTML5

#### 与类相关的扩充

1.  getElementsByClassName()方法，接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的 NodeList。

- 传入多个类名时，类名的先后顺序不重要。
- 在 document 对象上调用 getElementsByClassName()始终会返回与类名匹配的所有元素，在元素上调用该方法就只会返回后代元素中匹配的元素。

2.  classList 属性,注意兼容问题

- 以往在操作类名时，需要通过 className 属性添加、删除和替换类名，都需要设置整个字符串的值。
- classList 属性是新集合类型 DOMTokenList 的实例，DOMTokenList 有一个表示自己包含多少元素的 length 属性，而要取得每个元素可以使用 item()方法，也可以使用方括号语法。此外，这个新类型还定义如下方法。 + add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。 + contains(value)：表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。 + remove(value)：从列表中删除给定的字符串。 + toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它

```
//删除"disabled"类
div.classList.remove("disabled");
//添加"current"类
div.classList.add("current");
//切换"user"类
div.classList.toggle("user");
```

#### 焦点管理

1. document.activeElement 属性，这个属性始终会引用 DOM 中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入（通常是通过按 Tab 键）和在代码中调用 focus()方法。默认情况下，文档刚刚加载完成时，document.activeElement 中保存的是 document.body 元素的引用。文档加载期间，document.activeElement 的值为 null。
2. document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。

#### HTMLDocument 的变化

1. Document 的 readyState 属性，通过它来实现一个指示文档已经加载完成的指示器，要实现这样一个指示器，必须借助 onload 事件处理程序设置一个标签，表明文档已经加载完毕，它有两个可能的值：

- loading，正在加载文档；
- complete，已经加载完文档。

```
if (document.readyState == "complete"){
 //执行操作
}
```

2. compatMode 的属性，这个属性说明浏览器采用了哪种渲染模式（标准还是混杂），在标准模式下，document.compatMode 的值等于"CSS1Compat"，而在混杂模式下，document.compatMode 的值等于"BackCompat"。
3. document.head 属性，引用文档的<head>元素

#### 字符集属性

1. charset 属性表示文档中实际使用的字符集，也可以用来指定新字符集
2. 是 defaultCharset，表示根据默认浏览器及操作系统的设置，当前文档默认的字符集应该是什么

#### 自定义数据属性，兼容性差

1. HTML5 规定可以为元素添加非标准的属性，但要添加前缀 data-，目的是为元素提供与渲染无关的信息，或者提供语义信息
2. 添加了自定义属性之后，可以通过元素的 dataset 属性来访问自定义属性的值。dataset 属性的值是 DOMStringMap 的一个实例，也就是一个名值对儿的映射。在这个映射中，每个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data-前缀

#### 插入标记

1. ，innerHTML 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的 HTML 标记

- 在写模式下，innerHTML 的值会被解析为 DOM 子树，替换调用元素原来的所有子节点。
- 限制：在大多数浏览器中，通过 innerHTML 插入<script>元素并不会执行其中的脚本

2. outerHTML 返回调用它的元素及所有子节点的 HTML 标签。

```
//新创建的<p>元素会取代 DOM 树中的<div>元素。
div.outerHTML = "<p>This is a paragraph.</p>";
```

3. insertAdjacentHTML()方法，它接收两个参数：插入位置和要插入的 HTML 文本，第一个参数必须是下列值之一：

- "beforebegin"，在当前元素之前插入一个紧邻的同辈元素；
- "afterbegin"，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；
- "beforeend"，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；
- "afterend"，在当前元素之后插入一个紧邻的同辈元素。

4. 内存与性能问题

- 使用本节介绍的方法替换子节点可能会导致浏览器的内存占用问题
- 提高效率,避免频繁使用 innerHTML

```
//单独构建字符串，然后再一次性地将结果字符串赋值给 innerHTML
var itemsHtml = "";
for (var i=0, len=values.length; i < len; i++){
 itemsHtml += "<li>" + values[i] + "</li>";
}
ul.innerHTML = itemsHtml;
```

#### scrollIntoView()方法

scrollIntoView()可以在所有 HTML 元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。如果给这个方法传入 true 作为参数，或者不传入任何参数，那么窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐。如果传入 false 作为参数，调用元素会尽可能全部出现在视口中

### 专有扩展

#### 文档模式

文档模式决定了你可以使用哪个级别的 CSS，可以在 JavaScript 中使用哪些 API，以及如何对待文档类型（doctype）

#### children 属性

#### contains()方法

1. contains()方法的应该是祖先节点，也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，该方法返回 true；否则，返回 false。
2. compareDocumentPosition()也能够确定节点间的关系。返回一个表示该关系的位掩码![](JavaScript高级程序设计_files/5.jpg)，

#### 插入文本

1.  innerText 属性，操作元素中包含的所有文本内容，包括子文档树中的文本，。在通过 innerText 读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。在通过 innerText 写入值时，结果会删除元素的所有子节点，插入包含相应文本值的文本节点。

- 设置 innerText 属性的同时，也对文本中存在的 HTML 语法字符（小于号、大于号、引号及和号）进行了编码，并且设置 innerText 永远只会生成当前节点的一个子文本节点

```
div.innerText = "Hello & welcome, <b>\"reader\"!</b>";
//输出下面这行
<div id="content">Hello &amp; welcome, &lt;b&gt;&quot;reader&quot;!&lt;/b&gt;</div>
//解决方法，过滤掉 HTML 标签
div.innerText = div.innerText;
```

- 注意。Firefox 虽然不支持 innerText，但支持作用类似的 textContent 属性 + innerText 与 textContent 返回的内容并不完全一样。比如，innerText 会忽略行内的样式和脚本，而 textContent 则会像返回其他文本一样返回行内的样式和脚本代码。避免跨浏览器兼容问题的最佳途径，就是从不包含行内样式或行内脚本的 DOM 子树副本或 DOM 片段中读取文本。

```
//跨浏览器兼容
function getInnerText(element){
 return (typeof element.textContent == "string") ?
 element.textContent : element.innerText;
}
function setInnerText(element, text){
 if (typeof element.textContent == "string"){
 element.textContent = text;
 } else {
 element.innerText = text;
 }
}
```

2. outerText 属性,跟 innerText 差不多，但在写模式下不同了：outerText 不只是替换调用它的元素的子节点，而是会替换整个元素（包括子节点），该属性尽量不要用

#### 滚动，没什么用

## DOM2,DOM3

DOM1 级主要定义的是 HTML 和 XML 文档的底层结构。DOM2 和 DOM3 级则在这个结构的基础上引入了更多交互能力，也支持了更高级的 XML 特性，分成了不同模块

- DOM2 级核心（DOM Level 2 Core）：在 1 级核心基础上构建，为节点添加了更多方法和属性。
- DOM2 级视图（DOM Level 2 Views）：为文档定义了基于样式信息的不同视图。
- DOM2 级事件（DOM Level 2 Events）：说明了如何使用事件与 DOM 文档交互。
- DOM2 级样式（DOM Level 2 Style）：定义了如何以编程方式来访问和改变 CSS 样式信息。
- DOM2 级遍历和范围（DOM Level 2 Traversal and Range）：引入了遍历 DOM 文档和选择其特定部分的新接口。
- DOM2 级 HTML（DOM Level 2 HTML）：在 1 级 HTML 基础上构建，添加了更多属性、方法和新接口。

### DOM 变化

#### 针对 XML 命名空间的变化，跟 HTML 无关

#### 其他方面的变化，了解就好

1. DocumentType 类型的变化，新增了 3 个属性：publicId、systemId 和 internalSubset。其中，前两个属性表示的是文档类型声明中的两个信息段
2. Document 类型的变化中唯一与命名空间无关的方法是 importNode()，不常用。这个方法的用途是从一个文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档结构的一部分。它接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。
3. defaultView 的属性，其中保存着一个指针，指向拥有给定文档的窗口（或框架），IE 不支持， IE 中有一个等价的属性名叫 parentWindow（）
4. “DOM2 级核心”还为 document.implementation 对象规定了两个新方法：createDocumentType()和 createDocument()。

- createDocumentType()用于创建一个新的 DocumentType 节点，接受 3 个参数：文档类型名称、publicId、systemId。
- createDocument()创建新文档，这个方法接受 3 个参数：针对文档中元素的 namespaceURI、文档元素的标签名、新文档的文档类型

5. “DOM2 级 HTML”模块也为 document.implementation 新增了一个方法，名叫 createHTMLDocument()，兼容性差，不推荐。这个方法的用途是创建一个完整的 HTML 文档，包括<html>、<head>、<title>和<body>元素。这个方法只接受一个参数，即新创建文档的标题（放在<title>元素中的字符串），返回新的 HTML 文档
6. isSupported()方法于确定当前节点具有什么能力，接受相同的两个参数：特性名和特性版本号，返回值是布尔值
7. isSameNode()和 isEqualNode()。这两个方法都接受一个节点参数，并在传入节点与引用的节点相同或相等时返回 true
8. setUserData()方法会将数据指定给节点，它接受 3 个参数：要设置的键、实际的数据（可以是任何数据类型）和处理函数
9. 框架的变化：框架和内嵌框架分别用 HTMLFrameElement 和 HTMLIFrameElement 表示，它们在 DOM2 级中都有了一个新属性，名叫 contentDocument。这个属性包含一个指针，指向表示框架内容的文档对象。IE8 之前不支持框架中的 contentDocument 属性，但支持一个名叫 contentWindow 的属性，该属性返回框架的 window 对象，而这个 window 对象又有一个 document 属性

### 样式

#### 访问元素的样式

1. style 对象是 CSSStyleDeclaration 的实例，包含着行内的样式，不包含外部样式。
2. 多数情况下，都可以通过简单地转换属性名的格式来实现转换，如 background-color 转为 backgroundColor。其中一个不能直接转换的 CSS 属性就是 float，因为这是保留字，一般浏览器用 cssFloat，IE 用 styleFloat
3. 设置属性时，最好始终都指定度量单位
4. style 对象定义了一些属性和方法

- cssText：通过它能够读取或写入到 style 特性中的 CSS 代码。

```
myDiv.style.cssText = "width: 25px; height: 100px; background-color: green";
alert(myDiv.style.cssText);
```

- length：应用给元素的 CSS 属性的数量。其与 item()方法配套使用，以便迭代在元素中定义的 CSS 属性

```
var prop, value, i, len;
for (i=0, len=myDiv.style.length; i < len; i++){
 prop = myDiv.style[i]; //或者 myDiv.style.item(i)
 value = myDiv.style.getPropertyValue(prop);
 alert(prop + " : " + value);
}
```

- parentRule：表示 CSS 信息的 CSSRule 对象。
- getPropertyCSSValue(propertyName)：返回包含给定属性值的 CSSValue 对象，不常用。这两个属性分别是：cssText 和 cssValueType。其中，cssText 属性的值与 getPropertyValue()返回的值相同，而 cssValueType 属性则是一个数值常量，表示值的类型：0 表示继承的值，1 表示基本的值，2 表示值列表，3 表示自定义的值
- getPropertyPriority(propertyName)：如果给定的属性使用了!important 设置，则返回"important"；否则，返回空字符串。
- getPropertyValue(propertyName)：返回给定属性的字符串值。
- item(index)：返回给定位置的 CSS 属性的名称。
- removeProperty(propertyName)：从样式中删除给定属性。
- setProperty(propertyName,value,priority)：将给定属性设置为相应的值，并加上优先权标志（"important"或者一个空字符串）。

5. getComputedStyle()方法。这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如":after"）。如果不需要伪元素信息，第二个参数可以是 null。getComputedStyle()方法返回一个 CSSStyleDeclaration 对象（与 style 属性的类型相同），其中包含当前元素的所有计算的样式，IE 不支持 getComputedStyle()方法，但支持 currentStyle 属性。记住所有计算的样式都是只读的；不能修改计算后样式对象中的 CSS 属性

#### 操作样式表，不常用

1. CSSStyleSheet 类型表示样式表，只读，继承自 StyleSheet，继承的属性：![](JavaScript高级程序设计_files/14.jpg)，自身的属性：![](JavaScript高级程序设计_files/15.jpg)
2. css 规则：CSSRule 对象表示样式表中的每一条规则，有一个实例为是 CSSStyleRule 类型表示样式信息，
3. CSSStyleRule 对象包含下列属性：![](JavaScript高级程序设计_files/16.jpg)
4. insertRule()方法可以向现有样式表中添加新规则，法接受两个参数：规则文本和表示在哪里插入规则的索引，注意 IE8-支持 addRule()
5. deleteRule()从样式表中删除规则，法接受一个参数：要删除的规则的位置，注意 IE 支持的类似方法叫 removeRule()，使用方法相同

#### 元素大小

1. 偏移量：元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）， 4 个属性可以取得元素的偏移量，属性是只读的

- offsetHeight：元素在垂直方向上占用的空间大小，以像素计
- offsetWidth：元素在水平方向上占用的空间大小，以像素计
- offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。
- offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。

2. 客户区大小，元素内容及其内边距所占据的空间大小，属性有两个：clientWidth 和 clientHeight。属性是只读的

- clientWidth 属性是元素内容区宽度加上左右内边距宽度；
- clientHeight 属性是元素内容区高度加上上下内边距高度

3. 滚动大小，包含滚动内容的元素的大小，相关属性

- scrollHeight：在没有滚动条的情况下，元素内容的总高度。
- scrollWidth：在没有滚动条的情况下，元素内容的总宽度。
- scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。
- scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。

4. 确定元素大小，getBoundingClientRect()方法。这个方法返回会一个矩形对象，包含 4 个属性：left、top、right 和 bottom

### 遍历

#### NodeIterator 类型

1. 创建实例：document.createNodeIterator()方法，接受 4 个参数

- root：想要作为搜索起点的树中的节点。
- whatToShow：表示要访问哪些节点的数字代码，参数是一个位掩码。![](JavaScript高级程序设计_files/17.jpg)
- filter：是一个 NodeFilter 对象（，或者一个表示应该接受还是拒绝某种特定节点的函数 + NodeFilter 对象只有一个方法，即 acceptNode()；如果应该访问给定的节点，该方法返回 NodeFilter.FILTER_ACCEPT，如果不应该访问给定的节点，该方法返回 NodeFilter.FILTER_SKIP，NodeFilter 是一个抽象的类型，因此不能直接创建它的实例。在必要时，只要创建一个包含 acceptNode()方法的对象，然后将这个对象传入 createNodeIterator()中即可

```
// 传入NodeFilter 对象
var filter = {
 acceptNode: function(node){
 return node.tagName.toLowerCase() == "p" ?
 NodeFilter.FILTER_ACCEPT :
  NodeFilter.FILTER_SKIP;
  }
 };
 var iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT,
  filter, false);

  //传入类似函数
var filter = function(node){
 return node.tagName.toLowerCase() == "p" ?
 NodeFilter.FILTER_ACCEPT :
 NodeFilter.FILTER_SKIP;
};
var iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT,
filter, false);
```

- entityReferenceExpansion：布尔值，表示是否要扩展实体引用。这个参数在 HTML 页面中没有用，因为其中的实体引用不能扩展。

2. NodeIterator 类型的两个主要方法是 nextNode()和 previousNode()
3. 遍历节点的示例

```
// 返回遍历中遇到的<li>元素
var div = document.getElementById("div1");
var filter = function(node){
 return node.tagName.toLowerCase() == "li" ?
 NodeFilter.FILTER_ACCEPT :
 NodeFilter.FILTER_SKIP;
};
var iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT,
 filter, false);
var node = iterator.nextNode();
while (node !== null) {
 alert(node.tagName); //输出标签名
 node = iterator.nextNode();
}
```

#### TreeWalker

1. TreeWalker 比 NodeIterator 更高级。除了包括 nextNode()和 previousNode()还提供了下列用于在不同方向上遍历 DOM 结构的方法。

- parentNode()：遍历到当前节点的父节点；
- firstChild()：遍历到当前节点的第一个子节点；
- lastChild()：遍历到当前节点的最后一个子节点；
- nextSibling()：遍历到当前节点的下一个同辈节点；
- previousSibling()：遍历到当前节点的上一个同辈节点。

2. 创建 TreeWalker 对象要使用 document.createTreeWalker()方法，这个方法接受的 4 个参数：作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值
3. 可以用 TreeWalker 代替 NodeIterator

```
var div = document.getElementById("div1");
var filter = function(node){
 return node.tagName.toLowerCase() == "li"?
 NodeFilter.FILTER_ACCEPT :
 NodeFilter.FILTER_SKIP; //这里修改成 NodeFilter.FILTER_REJECT，就不会访问任何节点
};
var walker= document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT,
 filter, false);
var node = iterator.nextNode();
while (node !== null) {
 alert(node.tagName); //输出标签名
 node = iterator.nextNode();
}
```

4. 使用 TreeWalker 遍历 DOM 树，即使不定义过滤器，也可以取得想要的某些元素

```
//直接定位<li>元素在文档结构中的位置
var div = document.getElementById("div1");
var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, null, false);
walker.firstChild(); //转到<p>
walker.nextSibling(); //转到<ul>
var node = walker.firstChild(); //转到第一个<li>
while (node !== null) {
 alert(node.tagName);
 node = walker.nextSibling();
}
```

### 范围

#### DOM 中的范围，暂时略过

1. document 对象的 createRange()方法，使用 hasFeature()或者直接检测该方法，都可以确定浏览器是否支持范围

```
var supportsRange = document.implementation.hasFeature("Range", "2.0");
var alsoSupportsRange = (typeof document.createRange == "function");
```

2. 使用 document.createRange()创建的范围由一个 Range 类型的实例表示，这个实例拥有很多属性和方法

- startContainer：包含范围起点的节点（即选区中第一个节点的父节点）。
- startOffset：范围在 startContainer 中起点的偏移量。如果 startContainer 是文本节点、注释节点或 CDATA 节点，那么 startOffset 就是范围起点之前跳过的字符数量。否则，startOffset 就是范围中第一个子节点的索引。
- endContainer：包含范围终点的节点（即选区中最后一个节点的父节点）。
- endOffset：范围在 endContainer 中终点的偏移量（与 startOffset 遵循相同的取值规则）。
- commonAncestorContainer：startContainer 和 endContainer 共同的祖先节点在文档树中位置最深的那个。

3. 用 DOM 范围实现简单选择，是使用 selectNode()或 selectNodeContents()。这两个方法都接受一个参数，即一个 DOM 节点，然后使用该节点中的信息来填充范围。

- selectNode()方法选择整个节点，包括其子节点
- selectNodeContents()方法则只选择节点的子节点

4. 用 DOM 范围实现复杂选择
5. 操作 DOM 范围中的内容
6. 插入 DOM 范围中的内容
7. 折叠 DOM 范围
8. 比较 DOM 范围
9. 复制 DOM 范围
10. 清理 DOM 范围

#### IE8 及更早版本中的范围

IE8 及早期版本支持一种类似的概念，即文本范围，可以调用 createTextRange()方法来创建文本范围

1. 用 IE 范围实现简单的选择
2. 使用 IE 范围实现复杂的选择
3. 操作 IE 范围中的内容
4. 折叠 IE 范围
5. 比较 IE 范围
6. 复制 IE 范围

## 事件

事件就是用户或浏览器自身执行的某种动作。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码

### 事件流，从页面中接收事件的顺序

#### 事件冒泡

事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）

#### 事件捕获

事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它

#### DOM 事件流

1. “DOM2 级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段
2. 首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应![](JavaScript高级程序设计_files/18.jpg)
3. 即使“DOM2 级事件”规范明确要求捕获阶段不会涉及事件目标，但大部分高级浏览器都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。

### 事件处理程序

响应某个事件的函数就叫做事件处理程序或事件侦听器，一般事件处理程序的名字以"on"开头，如 onclick,onload 等

#### HTML 事件处理程序，不常用

写在 HTML 代码里的

```
<input type="button" value="Click Me" onclick="alert('Clicked')" />
<input type="button" value="Click Me" onclick="showMessage()" />
<input type="button" value="Click Me" onclick="alert(this.value)">
```

1. 特别之处：这样会创建一个封装着元素属性值的函数。这个函数中有一个局部变量 event，也就是事件对象，通过 event 变量，可以直接访问事件对象，并且在这个函数内部，this 值等于事件的目标元素
2. 缺点：

- 存在一个时差问题。 + 因为用户可能会在 HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件 + 解决:很多 HTML 事件处理程序都会被封装在一个 try-catch 块中，以便错误不会浮出水面

```
<input type="button" value="Click Me" onclick="try{showMessage();}catch(ex){}">
```

- 这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果
- HTML 与 JavaScript 代码紧密耦合

#### DOM0 级事件处理程序

在 js 代码域里写，把函数赋值给一个事件

```
var btn = document.getElementById("myBtn");
btn.onclick = function(){
 alert("Clicked");
};
```

1. 使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行；换句话说，程序中的 this 引用当前元素
2. 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理
3. 删除通过 DOM0 级方法指定的事件处理程序

```
btn.onclick = null; //删除事件处理程序
```

#### DOM2 级事件处理程序

使用 addEventListener()和 removeEventListener()

```
var btn = document.getElementById("myBtn");
btn.addEventListener("click", function(){ //注意不是onclick
 alert(this.id);
}, false);
```

1. 所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。
2. 使用 DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序
3. 通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同
4. 注意：通过 addEventListener()添加的匿名函数将无法移除，因为匿名函数无法存在相同的函数

#### IE 事件处理程序

attachEvent()和 detachEvent()

```
var btn = document.getElementById("myBtn");
btn.attachEvent("onclick", function(){
 alert("Clicked");
});
```

1. 这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数，
2. 通过 attachEvent()添加的事件处理程序都会被添加到冒泡阶段
3. 与 DOM0 级方法的区别：事件处理程序的作用域不同

- DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行
- attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window。

4. 使用 attachEvent()，为同一个按钮添加了多个不同的事件处理程序，程序以相反的顺序被触发。
5. 使用 attachEvent()添加的事件可以通过 detachEvent()来移除，条件是必须提供相同的参数。与 DOM 方法一样，这也意味着添加的匿名函数将不能被移除

#### 跨浏览器的事件处理程序

1. 要保证处理事件的代码能在大多数浏览器下一致地运行，只需关注冒泡阶段
2. addHandler()，它的职责是视情况分别使用 DOM0 级方法、DOM2 级方法或 IE 方法来添加事件。这个方法属于一个名叫 EventUtil 的对象，使用这个对象来处理浏览器间的差异。addHandler()方法接受 3 个参数：要操作的元素、事件名称和事件处理程序函数。
3. removeHandler()，接受与 addHandler()相同的参数。这个方法的职责是移除之前添加的事件处理程序——无论该事件处理程序是采取什么方式添加到元素中的，如果其他方法无效，默认采用 DOM0 级方法

```
var EventUtil = {
 addHandler: function(element, type, handler){
 if (element.addEventListener){
 element.addEventListener(type, handler, false);
 } else if (element.attachEvent){
 element.attachEvent("on" + type, handler);
 } else {
 element["on" + type] = handler;
 }
 },
 removeHandler: function(element, type, handler){
 if (element.removeEventListener){
 element.removeEventListener(type, handler, false);
 } else if (element.detachEvent){
 element.detachEvent("on" + type, handler);
 } else {
 element["on" + type] = null;
 }
 }
};

var btn = document.getElementById("myBtn");
var handler = function(){
 alert("Clicked");
};
EventUtil.addHandler(btn, "click", handler);
```

### 事件对象

在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。只有在事件处理程序执行期间，event 对象才会存在

#### DOM 中的事件对象

1. 兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中，无论是用 DOM0 级或 DOM2 级

```
var btn = document.getElementById("myBtn");
btn.onclick = function(event){
 alert(event.type); //"click"
};
btn.addEventListener("click", function(event){
 alert(event.type); //"click"
}, false);
```

2. event 对象属性![](JavaScript高级程序设计_files/19.jpg)![](JavaScript高级程序设计_files/20.jpg)
3. 在事件处理程序内部，对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则 this、currentTarget 和 target 包含相同的值。

```
var btn = document.getElementById("myBtn");
btn.onclick = function(event){
 alert(event.currentTarget === this); //true
 alert(event.target === this); //true
};
```

4. 在需要通过一个函数处理多个事件时，可以使用 type 属性

```
var btn = document.getElementById("myBtn");
var handler = function(event){
switch(event.type){
 case "click":
 alert("Clicked");
 break;
 case "mouseover":
 event.target.style.backgroundColor = "red";
 break;
 case "mouseout":
 event.target.style.backgroundColor = "";
 break;
 }
};
btn.onclick = handler;
btn.onmouseover = handler;
btn.onmouseout = handler;
```

5. 要阻止特定事件的默认行为，可以使用 preventDefault()方法，注意只有 cancelable 属性设置为 true 的事件，才可以使用 preventDefault()来取消其默认行为

```
//阻止链接导航
var link = document.getElementById("myLink");
link.onclick = function(event){
 event.preventDefault();
};
```

6. stopPropagation()方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡

```
//避免触发注册在 document.body 上面的事件处理程序
var btn = document.getElementById("myBtn");
btn.onclick = function(event){
 alert("Clicked");
 event.stopPropagation();
};
document.body.onclick = function(event){
 alert("Body clicked");
};
```

7. eventPhase 属性，可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶段调用的事件处理程序，那么 eventPhase 等于 1；如果事件处理程序处于目标对象上，则 eventPhase 等于 2；如果是在冒泡阶段调用的事件处理程序，eventPhase 等于 3
8. 在 HTML 里面指定的事件处理程序，那么还可以通过一个名叫 event 的变量来访问 event 对象

```
<input type="button" value="Click Me" onclick="alert(event.type)">
```

#### IE 中的事件对象

1. 在使用 DOM0 级方法添加事件处理程序时，event 对象作为 window 对象的一个属性存在

```
var btn = document.getElementById("myBtn");
btn.onclick = function(){
 var event = window.event;
 alert(event.type); //"click"
};
```

2. 使用 attachEvent()添加的，那么就会有一个 event 对象作为参数被传入事件处理程序函数中
3. 在 HTML 里面指定的事件处理程序，那么还可以通过一个名叫 event 的变量来访问 event 对象
4. IE 的 event 对象的属性或方法![](JavaScript高级程序设计_files/21.jpg)
5. 因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为 this 会始终等于事件目标。故而，最好还是使用 event.srcElement 比较保险

```
var btn = document.getElementById("myBtn");
btn.onclick = function(){
 alert(window.event.srcElement === this); //true
};
btn.attachEvent("onclick", function(event){
 alert(event.srcElement === this); //false
});
```

6. returnValue 属性相当于 DOM 中的 preventDefault()方法，它们的作用都是取消给定事件的默认行为。只要将 returnValue 设置为 false，就可以阻止默认行为
7. ，cancelBubble 属性是用来停止事件冒泡的(IE 不支持事件捕获)

#### 跨浏览器的事件对象，P378

### 事件类型

#### UI 事件

1. UI 事件指的是那些不一定与用户操作有关的事件

- load：当页面完全加载后在 window 上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在<img>元素上面触发，或者当嵌入的内容加载完毕时在<object>元素上面触发。
- unload：当页面完全卸载后在 window 上面触发，当所有框架都卸载后在框架集上面触发，或者当嵌入的内容卸载完毕后在<object>元素上面触发。
- abort：在用户停止下载过程时，如果嵌入的内容没有加载完，则在<object>元素上面触发。
- error：当发生 JavaScript 错误时在 window 上面触发，当无法加载图像时在<img>元素上面触发，当无法加载嵌入内容时在<object>元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发
- select：当用户选择文本框（<input>或<texterea>）中的一或多个字符时触发
- resize：当窗口或框架的大小变化时在 window 或框架上面触发
- scroll：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。<body>元素中包含所加载页面的滚动条。

2. 这些事件在 DOM2 级事件中都归为 HTML 事件，确定浏览器是否支持

```
//要确定浏览器是否支持 DOM2 级事件规定的 HTML 事件，true为支持
var isSupported = document.implementation.hasFeature("HTMLEvents", "2.0");
//确定浏览器是否支持“DOM3 级事件”定义的事件
var isSupported = document.implementation.hasFeature("UIEvent", "3.0");
```

3. load 事件，当页面完全加载后（包括所有图像、JavaScript 文件、CSS 文件等外部资源），就会触发 window 上面的 load 事件

- 定义 onload 事件处理程序的方式： + 使用 js 代码，推荐这个

```
//EventUtil在前面定义的可以跨浏览器的对象
EventUtil.addHandler(window, "load", function(event){
 alert("Loaded!");
});
```

    + 为<body>元素添加一个 onload 特性

- 图像上面也可以触发 load 事件
- 在高版本浏览器中，script 元素也会触发 load 事件，以便开发人员确定动态加载的 JavaScript 文件是否加载完毕，只有在设置了 script 元素的 src 属性并将该元素添加到文档后，才会开始下载 JavaScript 文件

4. unload 事件在文档被完全卸载后（用户从一个页面切换到另一个页面）触发，

- 用处：清除引用，以避免内存泄漏
- 定义方式 + 用 js 代码

```
//此时生成的 event 对象在兼容 DOM 的浏览器中只包含 target 属性（值为 document）
EventUtil.addHandler(window, "unload", function(event){
 alert("Unloaded");
});
```

    + <body>元素添加一个特性

5. resize 事件

- 当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件,这个事件在 window（窗口）上面触发，因此可以通过 JavaScript 或者<body>元素中的 onresize 特性来指定事件处理程序

```
EventUtil.addHandler(window, "resize", function(event){
 alert("Resized");
});
```

6. scroll 事件

- 在混杂模式下，可以通过<body>元素的 scrollLeft 和 scrollTop 来监控到这一变化；
- 在标准模式下，除 Safari 之外的所有浏览器都会通过<html>元素来反映这一变化（Safari 仍然基于<body>跟踪滚动位置

#### 焦点事件，不冒泡

1. 焦点事件会在页面元素获得或失去焦点时触发，利用这些事件并与 document.hasFocus()方法及 document.activeElement 属性配合，可以知晓用户在页面上的行踪
2. 有 4 个焦点事件

- blur：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。
- focus：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。
- focusin：在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡。支持这个事件的浏览器有 IE5.5+、Safari 5.1+、Opera 11.5+和 Chrome。
- focusout：在元素失去焦点时触发。这个事件是 HTML 事件 blur 的通用版本。支持这个事件的浏览器有 IE5.5+、Safari 5.1+、Opera 11.5+和 Chrome。

3. 当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件：

- focusout 在失去焦点的元素上触发；
- focusin 在获得焦点的元素上触发；
- blur 在失去焦点的元素上触发；
- focus 在获得焦点的元素上触发；

4. 要确定浏览器是否支持这些事件，可以使用如下代码：

```
var isSupported = document.implementation.hasFeature("FocusEvent", "3.0");
```

#### 鼠标与滚轮事件

1. 主要的鼠标事件

- click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。这一点对确保易访问性很重要，意味着 onclick 事件处理程序既可以通过键盘也可以通过鼠标执行。
- dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发
- mousedown：在用户按下了任意鼠标按钮时触发。
- mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发
- mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发
- mousemove：当鼠标指针在元素内部移动时重复地触发。
- mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时在原元素上触发
- mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时在新元素上触发。
- mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件

2. 事件关系

- 只有在同一个元素上相继触发 mousedown 和 mouseup 事件，才会触发 click 事件
- 只有触发两次 click 事件，才会触发一次 dblclick 事件
- 一次 dblclick 事件触发的顺序：mousedown--mouseup--click--mousedown--mouseup--click--dbclick

3. 检测浏览器是否支持

```
//DOM2级
var isSupported = document.implementation.hasFeature("MouseEvents", "2.0");
//DOM3级
var isSupported = document.implementation.hasFeature("MouseEvent", "3.0")
```

4. 客户区坐标位置
   鼠标事件发生时鼠标指针在视口中的水平和垂直坐标为事件对象的 clientX 和 clientY 属性
5. 页面坐标位置
   页面坐标通过事件对象的 pageX 和 pageY 属性，能告诉你事件是在页面中的什么位置发生的
   在页面没有滚动的情况下，pageX 和 pageY 的值与 clientX 和 clientY 的值相等。
6. 屏幕坐标位置
   通过 screenX 和 screenY 属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息
7. 修改键
   Shift、Ctrl、Alt 和 Meta（在 Windows 键盘中是 Windows 键，在苹果机中是 Cmd 键）被用来修改鼠标事件的行为
8. 相关元素

- 对 mouseover 事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素。
- 对 mouseout 事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素
- DOM 通过 event 对象的 relatedTarget 属性提供了相关元素的信息。这个属性只对于 mouseover 和 mouseout 事件才包含值；对于其他事件，这个属性的值是 null

9. 鼠标按钮

- 对于 mousedown 和 mouseup 事件来说，则在其 event 对象存在一个 button 属性，表示按下或释放的按钮。
- DOM 的 button 属性可能有如下 3 个值：0 表示主鼠标按钮，1 表示中间的鼠标按钮（鼠标滚轮按钮），2 表示次鼠标按钮

10. 更多事件信息

- event 对象中还提供了 detail 属性，用于给出有关事件的更多信息
- 对于鼠标事件来说，detail 中包含了一个数值，表示在给定位置上发生了多少次单击，鼠标移动后数字清零

11. 鼠标滚轮事件
    当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发 mousewheel
    事件。这个事件可以在任何元素上面触发，最终会冒泡到 document（IE8）或 window（IE9、Opera、Chrome 及 Safari）对象
12. 触摸设备，移动端
    注意几点：

- 不支持 dblclick 事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。
- 轻击可单击元素会触发 mousemove 事件。如果此操作会导致内容变化，将不再有其他事件发生；如果屏幕没有因此变化，那么会依次发生 mousedown、mouseup 和 click 事件。轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了 onclick 事件处理程序的元素。
- mousemove 事件也会触发 mouseover 和 mouseout 事件。
- 两个手指放在屏幕上且页面随手指移动而滚动时会触发 mousewheel 和 scroll 事件。

13. 无障碍性问题，使用屏幕阅读器的

- 使用 click 事件执行代码。有人指出通过 onmousedown 执行代码会让人觉得速度更快，对视力正常的人来说这是没错的。但是，在屏幕阅读器中，由于无法触发 mousedown 事件，结果就会造成代码无法执行。
- 不要使用 onmouseover 向用户显示新的选项。原因同上，屏幕阅读器无法触发这个事件。如果确实非要通过这种方式来显示新选项，可以考虑添加显示相同信息的键盘快捷方式。
- 不要使用 dblclick 执行重要的操作。键盘无法触发这个事件。

#### 键盘与文本事件

1. 3 个键盘事件

- keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。
- keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下 Esc 键也会触发这个事件。Safari 3.1 之前的版本也会在用户按下非字符键时触发 keypress 事件。
- keyup：当用户释放键盘上的键时触发
- 触发顺序 1：在用户按了一下键盘上的字符键时，首先会触发 keydown 事件，然后紧跟着是 keypress 事件，最后会触发 keyup 事件。 + 其中，keydown 和 keypress 都是在文本框发生变化之前被触发的； + 而 keyup 事件则是在文本框已经发生变化之后被触发的。 + 如果用户按下了一个字符键不放，就会重复触发 keydown 和 keypress 事件，直到用户松开该键为止。
- 触发顺序 2：如果用户按下的是一个非字符键，那么首先会触发 keydown 事件，然后就是 keyup 事件。 + 如果按住这个非字符键不放，那么就会一直重复触发 keydown 事件，直到用户松开这个键，此时会触发 keyup 事件。

2. 1 个文本事件：textInput，在文本插入文本框之前会触发 textInput 事件
3. 键码

- 在发生 keydown 和 keyup 事件时，event 对象的 keyCode 属性中会包含一个代码，与键盘上一个特定的键对应
- 键码表![键码表1](JavaScript高级程序设计_files/22.jpg)![键码表2](JavaScript高级程序设计_files/23.jpg)
- 字符编码--对应字符的 ASCII 编码

4. DOM3 变化

- DOM3 级事件中的键盘事件，包含两个新属性：key 和 char。兼容性不好，不推荐

5. textInput 事件，当用户在可编辑区域中输入实际字符时，就会触发这个事件，它的 event 对象中还包含一个 data 属性，这个属性的值就是用户输入的字符（而非字符编码）。

#### 复合事件

复合事件，用于处理 IME 的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符

#### 变动事件

#### HTML5 事件

1. contextmenu 事件表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单
2. beforeunload 事件，会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。这个事件的意图是将控制权交给用户。显示的消息会告知用户页面行将被卸载（正因为如此才会显示这个消息），询问用户是否真的要关闭页面，还是希望继续留下来
3. DOMContentLoaded 事件在形成完整的 DOM 树之后就会触发，不理会图像、JavaScript 文件、CSS 文件或其他资源是否已经下载完毕
4. readystatechange 事件，提供与文档或元素的加载状态有关的信息
5. pageshow 和 pagehide 事件

- Firefox 和 Opera 有一个特性，名叫“往返缓存”（back-forward cache，或 bfcache），可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存中不仅保存着页面数据，还保存了 DOM 和 JavaScript 的状态
- pageshow 这个事件在页面显示时触发，无论该页面是否来自 bfcache
- 是 pagehide 事件，该事件会在浏览器卸载页面的时候触发，而且是在 unload 事件之前触发

6. hashchange 事件

- 用处：在 URL 的参数列表（及 URL 中“#”号后面的所有字符串）发生变化时通知开发人员。之所以新增这个事件，是因为在 Ajax 应用中，开发人员经常要利用 URL 参数列表来保存状态或导航信息
- 必须要把 hashchange 事件处理程序添加给 window 对象，然后 URL 参数列表只要变化就会调用它。此时的 event 对象应该额外包含两个属性：oldURL 和 newURL。这两个属性分别保存着参数列表变化前后的完整 URL，注意这两个属性只有 Firefox 6+、Chrome 和 Opera 支持，所以还是用 location 对象来确定当前的参数列表

#### 设备事件，移动端的

#### 触摸与手势事件，移动端

### 内存与性能

1. 过多的添加事件处理程序会影响到页面的整体性能，首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪时间

#### 事件委托

1. 事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。

- 使用事件委托，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序。原理是由于所有列表项都是这个元素的子节点，而且它们的事件会冒泡，所以单击事件最终会被这个函数处理

2. 适合采用事件委托技术的事件包括 click、mousedown、mouseup、keydown、keyup 和 keypress。虽然 mouseover 和 mouseout 事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置。

#### 移除事件处理程序

1. 前因：

- 每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 JavaScript 代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。
- 内存中留有那些过时不用的“空事件处理程序”占用内存，影响性能 + 通过纯粹的 DOM 操作，从文档中移除带有事件处理程序的元素时，例如使用 innerHTML 替换页面中某一部分的时候，原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收 + 卸载页面的时候，。如果在页面被卸载之前没有清理干净事件处理程序，那它们就会滞留在内存中

2. 处理 1：

- 如果你知道某个元素即将被移除，那么最好手工移除事件处理程序

```
<div id="myDiv">
 <input type="button" value="Click Me" id="myBtn">
</div>
<script type="text/javascript">
 var btn = document.getElementById("myBtn");
 btn.onclick = function(){
  //先执行某些操作
  btn.onclick = null; //移除事件处理程序
  document.getElementById("myDiv").innerHTML = "Processing...";
  };
 </script>
```

- 在事件处理程序中删除按钮也能阻止事件冒泡。目标元素在文档中是事件冒泡的前提

3. 处理 2：在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序

### 模拟事件

#### DOM 中的事件模拟

1. 模拟事件创建流程

- 在 document 对象上使用 createEvent()方法创建 event 对象。这个方法接收一个参数，即表示要创建的事件类型的字符串，可以为 + UIEvents：一般化的 UI 事件。鼠标事件和键盘事件都继承自 UI 事件。DOM3 级中是 UIEvent。  
   + MouseEvents：一般化的鼠标事件。DOM3 级中是 MouseEvent。  
   + MutationEvents：一般化的 DOM 变动事件。DOM3 级中是 MutationEvent。 + HTMLEvents：一般化的 HTML 事件。没有对应的 DOM3 级事件（HTML 事件被分散到其他类别中）。
- 创建了 event 对象之后，还需要使用与事件有关的信息对其进行初始化
- 最后一步就是触发事件。这一步需要使用 dispatchEvent()方法，需要传入一个参数，即表示要触发事件的 event 对象

2. 模拟鼠标事件

- 创建鼠标事件对象的方法是为 createEvent()传入字符串"MouseEvents"。返回的对象有一个名为 initMouseEvent()方法，用于指定与该鼠标事件有关的信息。这个方法接收 15 个参数，分别与鼠标事件中每个典型的属性一一对应![initMouseEvent()方法参数值](JavaScript高级程序设计_files/24.jpg)

```
var btn = document.getElementById("myBtn");
//创建事件对象
var event = document.createEvent("MouseEvents");
//初始化事件对象
event.initMouseEvent("click", true, true, document.defaultView, 0, 0, 0, 0, 0,
 false, false, false, false, 0, null);
//触发事件
btn.dispatchEvent(event);
```

3. 模拟键盘事件
4. 模拟其他事件
5. 自定义 DOM 事件

#### IE 中的事件模拟

1. 调用 document.createEventObject()方法可以在 IE 中创建 event 对象，返回一个通用的 event 对象
2. 为这个对象添加所有必要的信息
3. 在目标上调用 fireEvent()方法，这个方法接受两个参数：事件处理程序的名称和 event 对象

```
var btn = document.getElementById("myBtn");
//创建事件对象
var event = document.createEventObject();
//初始化事件对象
event.screenX = 100;
event.screenY = 0;
event.clientX = 0;
event.clientY = 0;
event.ctrlKey = false;
event.altKey = false;
event.shiftKey = false;
event.button = 0;
//触发事件
btn.fireEvent("onclick", event);
```

## 表单脚本

### 表单的基础知识

1. 在 JavaScript 中，表单对应的则是 HTMLFormElement 类型（继承 HTMLElement），特有属性和方法：

- acceptCharset：服务器能够处理的字符集；等价于 HTML 中的 accept-charset 特性。
- action：接受请求的 URL；等价于 HTML 中的 action 特性。
- elements：表单中所有控件的集合（HTMLCollection）。
- enctype：请求的编码类型；等价于 HTML 中的 enctype 特性。
- length：表单中控件的数量。
- method：要发送的 HTTP 请求类型，通常是"get"或"post"；等价于 HTML 的 method 特性。
- name：表单的名称；等价于 HTML 的 name 特性。
- reset()：将所有表单域重置为默认值。
- submit()：提交表单。
- target：用于发送请求和接收响应的窗口名称；等价于 HTML 的 target 特性。

2. 获取 form 元素

- 与其他元素一样，为其添加 id 特性，再使用 getElementById()方法。
- 通过 document.forms 可以取得页面中所有的表单，在使用索引或 name 值

```
var firstForm = document.forms[0]; //取得页面中的第一个表单
var myForm = document.forms["form2"]; //取得页面中名称为"form2"的表单
```

#### 提交表单

1. 单击提交按钮或图像按钮时，就会提交表单，以这种方式提交表单时，浏览器会在将请求发送给服务器之前触发 submit 事件

- 用<input>或<button>都可以定义提交按钮，只要将其 type 特性的值设置为"submit"即可
- 将<input>的 type 特性值设置为"image"来定义的，点击按钮也可以提交

2. 在 js 里，调用 submit()方法也可以提交表单，但不会触发 submit 事件

```
var form = document.getElementById("myForm");
//提交表单
form.submit();
```

3. 取消表单提交，通过阻止 submit 事件默认行为

```
var form = document.getElementById("myForm");
//EventUtil是上一章自定义的，可以方便跨浏览器处理
EventUtil.addHandler(form, "submit", function(event){
 //取得事件对象
 event = EventUtil.getEvent(event);
 //阻止默认事件
 EventUtil.preventDefault(event);
});
```

4. 提交表单容易出现的问题：重复提交（用户不耐烦），可能会造成错误，解决方法：在第一次提交表单后就禁用提交按钮，或者利用 onsubmit 事件处理程序取消后续的表单提交操作

#### 重置表单

1. 使用 type 特性值为"reset"的<input>或<button>都可以创建重置按钮，点击即重置，触发 reset 事件，利用这个机会，我们可以在必要时取消重置操作
2. 使用 js 重置

```
var form = document.getElementById("myForm");
//重置表单
form.reset();
```

3. 阻止重置

```
var form = document.getElementById("myForm");
EventUtil.addHandler(form, "reset", function(event){
 //取得事件对象
 event = EventUtil.getEvent(event);
 //阻止表单重置
 EventUtil.preventDefault(event);
});
```

#### 表单字段

1. 表单有 elements 属性,该属性是表单中所有表单元素（字段）的集合,这个 elements 集合是一个有序列表，其中包含着表单中的所有字段,。每个表单字段在 elements 集合中的顺序，与它们出现在标记中的顺序相同，可以按照位置和 name 特性来访问它们
2. 如果有多个表单控件都在使用一个 name（如单选按钮），那么就会返回以该 name 命名的一个 NodeList,如果需要访问单个元素，则需要使用角标
3. 共有的表单字段属性

- disabled：布尔值，表示当前字段是否被禁用。
- form：指向当前字段所属表单的指针；只读。
- name：当前字段的名称。
- readOnly：布尔值，表示当前字段是否只读。
- tabIndex：表示当前字段的切换（tab）序号。
- type：当前字段的类型，如"checkbox"、"radio"，等等。
- value：当前字段将被提交给服务器的值。对文件字段来说，这个属性是只读的，包含着文件在计算机中的路径。

4. 共有的表单字段方法：focus()和 blur()

- focus()方法用于将浏览器的焦点设置到表单字段，即激活表单字段，使其可以响应键盘事件。注意如果是 type 特性的值为"hidden"<input>元素或者使用 CSS 的 display 和 visibility 属性隐藏了该字段，使用 focus 方法会报错
- HTML5 为表单字段新增了一个 autofocus 属性，是一个布尔值属性，所以在支持的浏览器中它的值应该是 true
- blur()方法，它的作用是从元素中移走焦点

5. 共有的表单字段事件

- blur：当前字段失去焦点时触发。
- change：对于<input>和<textarea>元素，在它们失去焦点且 value 值改变时触发；对于<select>元素，在其选项改变时触发。
- focus：当前字段获得焦点时触发。

### 文本框脚本

1. HTML 中的文本框：

- <input>元素的单行文本框，type 特性设置为"text"，通过设置 size 特性，可以指定文本框中能够显示的字符数。通过 value 特性，可以设置文本框的初始值，而 maxlength 特性则用于指定文本框可以接受的最大字符数，用户输入的内容保存在 value 属性中
- <textarea>的多行文本框，rows 特性指定的是文本框的字符行数，而 cols 特性指定的是文本框的字符列数，用户输入的内容保存在 value 属性中

#### 选择文本

1. select()方法，这个方法用于选择文本框中的所有文本，调用 select()方法时，大多数浏览器（Opera 除外）都会将焦点设置到文本框中。这个方法不接受参数，可以在任何时候被调用
2. 选择事件，在选择了文本框中的文本时，就会触发 select 事件
3. 取得选择的文本：h5 新增两个属性：selectionStart 和 selectionEnd，这两个属性中保存的是基于 0 的数值，表示所选择文本的范围，不过 IE8 以上不支持，兼容的方法为

```
//取得选择的文本
function getSelectedText(textbox){
if (typeof textbox.selectionStart == "number"){
 return textbox.value.substring(textbox.selectionStart,
 textbox.selectionEnd);
} else if (document.selection){
return document.selection.createRange().text;
}
}
```

4. 选择部分文本：setSelectionRange()方法。这个方法接收两个参数：要选择的第一个字符的索引和要选择的最后一个字符之后的字符的索引，IE8 不支持

```
//兼容方式
function selectText(textbox, startIndex, stopIndex){
 if (textbox.setSelectionRange){
 textbox.setSelectionRange(startIndex, stopIndex);
 } else if (textbox.createTextRange){ //IE8支持
 var range = textbox.createTextRange();
 range.collapse(true);
 range.moveStart("character", startIndex);
 range.moveEnd("character", stopIndex - startIndex);
 range.select();
 }
  textbox.focus();
 }
```

#### 过滤输入

1. 屏蔽字符，通过阻止 keypress 事件的默认行为来屏蔽此类字符

```
// 只允许用户输入数值
EventUtil.addHandler(textbox, "keypress", function(event){
 event = EventUtil.getEvent(event);
 var target = EventUtil.getTarget(event);
 var charCode = EventUtil.getCharCode(event);
 if (!/\d/.test(String.fromCharCode(charCode)) && charCode > 9){
	 /*  \d:0-9的数字，test是正则匹配，String.fromCharCode()将字符编码转换成字符串，charCode > 9是为了兼容火狐和Safari */
	 EventUtil.preventDefault(event);
	 }
	 });
```

2. 操作剪贴板，

- 剪贴板事件： + beforecopy：在发生复制操作前触发。 + copy：在发生复制操作时触发。 + beforecut：在发生剪切操作前触发。 + cut：在发生剪切操作时触发。 + beforepaste：在发生粘贴操作前触发。 + paste：在发生粘贴操作时触发。
- 访问剪贴板中的数据，可以使用 clipboardData 对象，在 IE 中，这个对象是 window 对象的属性；而在 Firefox 4+、Safari 和 Chrome 中，这个对象是相应 event 对象的属性，只在发生剪贴板事件期间使用这个对象，它有三个方法 + getData()用于从剪贴板中取得数据，它接受一个参数，即要取得的数据的格式 + setData()方法的第一个参数也是数据类型，第二个参数是要放在剪贴板中的文本

#### 自动切换焦点

1. 在用户填写完当前字段时，自动将焦点切换到下一个字段，在自动切换焦点之前，必须知道用户已经输入了既定长度的数据，比如填那种分成几段的电话号码

```
html代码
<input type="text" name="tel1" id="txtTel1" maxlength="3">
<input type="text" name="tel2" id="txtTel2" maxlength="3">
<input type="text" name="tel3" id="txtTel3" maxlength="4">
js代码
(function(){
 function tabForward(event){
 event = EventUtil.getEvent(event);
 var target = EventUtil.getTarget(event);
 if (target.value.length == target.maxLength){
 var form = target.form;
 for (var i=0, len=form.elements.length; i < len; i++) {
 if (form.elements[i] == target) {
 if (form.elements[i+1]){
 form.elements[i+1].focus();
 }
 return;
 }
 }
 }
 }
 var textbox1 = document.getElementById("txtTel1");
 var textbox2 = document.getElementById("txtTel2");
 var textbox3 = document.getElementById("txtTel3");
 EventUtil.addHandler(textbox1, "keyup", tabForward);
 EventUtil.addHandler(textbox2, "keyup", tabForward);
 EventUtil.addHandler(textbox3, "keyup", tabForward);
})();
```

#### h5 约束验证 API(自动验证)

1. 必填字段：在表单字段中指定了 required 属性，适用于<input>、<textarea>和<select>字段
2. 其他输入类型："email"和"url"类型，"email"类型要求输入的文本必须符合电子邮件地址的模式，而"url"类型要求输入的文本必须符合 URL 的模式
3. 数值范围："number"、"range"、"datetime"、"datetime-local"、"date"、"month"、"week"，还有"time"。对所有这些数值类型的输入元素，可以指定 min 属性（最小的可能值）、max 属性（最大的可能值）和 step 属性（从 min 到 max 的两个刻度间的差值），注意这些类型不一定能用
4. 输入模式：pattern 属性。这个属性的值是一个正则表达式，用于匹配文本框中的值，注意，模式的开头和末尾不用加^和\$符号
5. 检测有效性：

- 使用 checkValidity()方法可以检测表单中的某个字段是否有效
- validity 属性则会告诉你为什么字段有效或无效![](JavaScript高级程序设计_files/25.jpg)

6. 禁用验证：通过在 HTML 里设置 novalidate 属性，可以告诉表单不进行验证。在 JavaScript 中使用 noValidate 属性可以取得或设置这个值，如果这个属性存在，值为 true，如果不存在，值为 false。

### 选择框脚本

1. HTMLSelectElement 类型特有方法

- add(newOption, relOption)：向控件中插入新<option>元素，其位置在相关项（relOption）之前。
- multiple：布尔值，表示是否允许多项选择；等价于 HTML 中的 multiple 特性。
- options：控件中所有<option>元素的 HTMLCollection。  remove(index)：移除给定位置的选项。
- selectedIndex：基于 0 的选中项的索引，如果没有选中项，则值为-1。对于支持多选的控件，只保存选中项中第一项的索引。
- size：选择框中可见的行数；等价于 HTML 中的 size 特性。

2. 选择框的 type 属性不是"select-one"，就是"select-multiple"，这取决于 HTML 代码中有没有 multiple 特性
3. 选择框的 value 属性由当前选中项决定，规则如下

- 如果没有选中的项，则选择框的 value 属性保存空字符串。
- 如果有一个选中项，而且该项的 value 特性已经在 HTML 中指定，则选择框的 value 属性等于选中项的 value 特性。即使 value 特性的值是空字符串，也同样遵循此条规则。
- 如果有一个选中项，但该项的 value 特性在 HTML 中未指定，则选择框的 value 属性等于该项的文本。
- 如果有多个选中项，则选择框的 value 属性将依据前两条规则取得第一个选中项的值。

4. HTMLOptionElement 对象属性

- index：当前选项在 options 集合中的索引。
- label：当前选项的标签；等价于 HTML 中的 label 特性。
- selected：布尔值，表示当前选项是否被选中。将这个属性设置为 true 可以选中当前选项。
- text：选项的文本。
- value：选项的值（等价于 HTML 中的 value 特性）。

```
var selectbox = document.forms[0]. elements["location"];
//推荐
var text = selectbox.options[0].text; //选项的文本
var value = selectbox.options[0].value; //选项的值
```

#### 选择选项

1. 对于单选，访问选中项的方式就是使用选择框的 selectedIndex 属性，多选不适用

```
//取得选中项和选中项的信息
var selectedOption = selectbox.options[selectbox.selectedIndex];
var selectedIndex = selectbox.selectedIndex;
var selectedOption = selectbox.options[selectedIndex];
```

2. selected 属性设置为 true 可以选中选项，selected 属性的作用主要是确定用户选择了选择框中的哪一项。要取得所有选中的项，可以循环遍历选项集合，然后测试每个选项的 selected 属性

```
//返回给定选择框中选中项的一个数组
function getSelectedOptions(selectbox){
 var result = new Array();
 var option = null;
 for (var i=0, len=selectbox.options.length; i < len; i++){
 option = selectbox.options[i];
 if (option.selected){
 result.push(option);
 }
 }
 return result;
}
// 对这个数组进行操作
var selectbox = document.getElementById("selLocation");
var selectedOptions = getSelectedOptions(selectbox);
var message = "";
for (var i=0, len=selectedOptions.length; i < len; i++){
 message += "Selected index: " + selectedOptions[i].index +
 "\nSelected text: " + selectedOptions[i].text +
 "\nSelected value: " + selectedOptions[i].value + "\n\n";
}
alert(message);
```

#### 添加选项

1. 使用 DOM 方法

```
var newOption = document.createElement("option");
newOption.appendChild(document.createTextNode("Option text"));
newOption.setAttribute("value", "Option value");
selectbox.appendChild(newOption);
```

2. 使用 Option 构造函数来创建新选项，接受两个参数：文本（text）和值（value）；第二个参数可选

```
var newOption = new Option("Option text", "Option value");
selectbox.appendChild(newOption); //在 IE8 及之前版本中有问题
```

3. 使用选择框的 add()方法,接受两个参数：要添加的新选项和将位于新选项之后的选项,第二个参数传入 undefined，就可以在所有浏览器中都将新选项插入到列表最后了

```
var newOption = new Option("Option text", "Option value");
selectbox.add(newOption, undefined); //最佳方案
```

4. 想将新选项添加到其他位置（不是最后一个），就应该使用标准的 DOM 技术和 insertBefore()方法。

#### 移除选项

1. 使用 DOM 的 removeChild()方法，为其传入要移除的选项

```
selectbox.removeChild(selectbox.options[0]); //移除第一个选项
```

2. 使用选择框的 remove()方法。这个方法接受一个参数，即要移除选项的索引

```
selectbox.remove(0); //移除第一个选项
```

3. 将相应选项设置为 null

```
selectbox.options[0] = null; //移除第一个选项
```

4. 清除选择框中所有的项，需要迭代所有选项并逐个移除它们

```
function clearSelectbox(selectbox){
 for(var i=0, len=selectbox.options.length; i < len; i++){
 selectbox.remove(i);
 }
}
```

#### 移动和重排选项

1. 使用 DOM 的 appendChild()方法，就可以将第一个选择框中的选项直接移动到第二个选择框中，原理是如果为 appendChild()方法传入一个文档中已有的元素，那么就会先从该元素的父节点中移除它，再把它添加到指定的位置
2. 要将选择框中的某一项移动到特定位置，最合适的 DOM 方法就是 insertBefore()

```
var optionToMove = selectbox.options[1];
selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index+2]);
```

### 表单序列化

1. 在表单提交期间，浏览器是怎样将数据发送给服务器的。

- 对表单字段的名称和值进行 URL 编码，使用和号（&）分隔。
- 不发送禁用的表单字段。
- 只发送勾选的复选框和单选按钮。
- 不发送 type 为"reset"和"button"的按钮。
- 多选选择框中的每个选中的值单独一个条目。
- 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。也包括 type 为"image"的<input>元素。
- <select>元素的值，就是选中的<option>元素的 value 特性的值。如果<option>元素没有 value 特性，则是<option>元素的文本值。

2. 实现表单序列化的代码

```
function serialize(form){
 var parts = [],
 field = null,
 i,
 len,
 j,
 optLen,
 option,
 optValue;
 for (i=0, len=form.elements.length; i < len; i++){
 field = form.elements[i];
 switch(field.type){
 case "select-one":
 case "select-multiple":
 if (field.name.length){
 for (j=0, optLen = field.options.length; j < optLen; j++){
	 option = field.options[j];
	  if (option.selected){
	  optValue = "";
	  if (option.hasAttribute){
	  optValue = (option.hasAttribute("value") ?
	  option.value : option.text);
	  } else {
	  optValue = (option.attributes["value"].specified ?
	  option.value : option.text);
	  }
	  parts.push(encodeURIComponent(field.name) + "=" +
	  encodeURIComponent(optValue));
	  }
	  }
	  }
	  break;
	  case undefined: //字段集
	  case "file": //文件输入
	  case "submit": //提交按钮
	  case "reset": //重置按钮
	  case "button": //自定义按钮
	  break;
	  case "radio": //单选按钮
	  case "checkbox": //复选框
	  if (!field.checked){
	  break;
	  }
	  /* 执行默认操作 */
	  default:
	  //不包含没有名字的表单字段
	  if (field.name.length){
	  parts.push(encodeURIComponent(field.name) + "=" +
	  encodeURIComponent(field.value));
	  }
	  }
	  }
	  return parts.join("&");
	 }
```

### 富文本编辑（WYSIWYG（What You See Is What You Get，所见即所得）。了解一下

1. 这一技术的本质，就是在页面中嵌入一个包含空 HTML 页面的 iframe。

- 通过设置 designMode 属性，这个空白的 HTML 页面可以被编辑，而编辑对象则是该页面<body>元素的 HTML 代码。
- designMode 属性有两个可能的值："off"（默认值）和"on"。在设置为"on"时，整个文档都会变得可以编辑（显示插入符号），然后就可以像使用字处理软件一样，通过键盘将文本内容加粗、变成斜体，等等

#### 使用 contenteditable 属性

1. 把 contenteditable 属性应用给页面中的任何元素，然后用户立即就可以编辑该元素
2. contenteditable 属性有三个可能的值："true"表示打开、"false"表示关闭，"inherit"表示
   从父元素那里继承

#### 操作富文本

1. 与富文本编辑器交互的主要方式，就是使用 document.execCommand()。
2. 可以为 document.execCommand()方法传递 3 个参数：要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值（建议始终为 false）和执行命令必须的一个值（如果不需要值，则传递 null）。
3. 预定义命令![](JavaScript高级程序设计_files/26.jpg)，![](JavaScript高级程序设计_files/27.jpg)

#### 富文本选区

1. 在富文本编辑器中，使用框架（iframe）的 getSelection()方法，可以确定实际选择的文本。这个方法是 window 对象和 document 对象的属性，调用它会返回一个表示当前选择文本的 Selection 对象
2. 每个 Selection 对象都有下列属性。

- anchorNode：选区起点所在的节点。
- anchorOffset：在到达选区起点位置之前跳过的 anchorNode 中的字符数量。
- focusNode：选区终点所在的节点。
- focusOffset：focusNode 中包含在选区之内的字符数量。
- isCollapsed：布尔值，表示选区的起点和终点是否重合。
- rangeCount：选区中包含的 DOM 范围的数量。

3.  Selection 对象的方法，![](JavaScript高级程序设计_files/28.jpg)

#### 表单与富文本

## 使用 Canvas 绘图

### 基本用法

1. 要使用<canvas>元素，必须先设置其 width 和 height 属性，指定可以绘图的区域大小。

```
<canvas id="drawing" width=" 200" height="200">A drawing of something.</canvas>
```

2. 要在这块画布（canvas）上绘图，需要取得绘图上下文。而取得绘图上下文对象的引用，需要调用 getContext()方法并传入上下文的名字,注意要先检测 getContext()方法是否存在
3. 使用 toDataURL()方法，可以导出在<canvas>元素上绘制的图像。这个方法接受一个参数，即图像的 MIME 类型格式，而且适合用于创建图像的任何上下文

```
//取得画布中的一幅 PNG 格式的图像
var drawing = document.getElementById("drawing");
//确定浏览器支持<canvas>元素
if (drawing.getContext){
 //取得图像的数据 URI
 var imgURI = drawing.toDataURL("image/png");
 //显示图像
 var image = document.createElement("img");
 image.src = imgURI;
 document.body.appendChild(image);
}
```

### 2D 上下文，可以绘制简单 2D 图形

2D 上下文的坐标开始于<canvas>元素的左上角，原点坐标是(0,0)。所有坐标值都基于这个原点计算，x 值越大表示越靠右，y 值越大表示越靠下。默认情况下，width 和 height 表示水平和垂直两个方向上可用的像素数目。

#### 填充与描边

1. 填充，就是用指定的样式（颜色、渐变或图像）填充图形；描边，就是只在图形的边缘画线，这两个操作的结果取决于于两个属性：fillStyle 和 strokeStyle。这两个属性的值可以是字符串、渐变对象或模式对象，而且它们的默认值都是"#000000"。

```
var drawing = document.getElementById("drawing");
//确定浏览器支持<canvas>元素
if (drawing.getContext){
 var context = drawing.getContext("2d");
 context.strokeStyle = "red";
 context.fillStyle = "#0000ff";
}
```

#### 绘制矩形

1. 矩形是唯一一种可以直接在 2D 上下文中绘制的形状
2. 与矩形有关的方法包括 fillRect()、strokeRect()和 clearRect()。这三个方法都能接收 4 个参数：矩形的 x 坐标、矩形的 y 坐标、矩形宽度和矩形高度。这些参数的单位都是像素。

- fillRect()方法在画布上绘制的矩形会填充指定的颜色。填充的颜色通过 fillStyle 属性指定
- strokeRect()方法在画布上绘制的矩形会使用指定的颜色描边。描边颜色通过 strokeStyle 属性指定
- clearRect()方法用于清除画布上的矩形区域，用处在于把绘制上下文中的某一矩形区域变透明，例如可以实现把某个形状切掉一块

#### 绘制路径

1. 要绘制路径，首先必须调用 beginPath()方法，表示要开始绘制新路径。然后，再通过调用下列方法来实际地绘制路径。

- arc(x, y, radius, startAngle, endAngle, counterclockwise)：以(x,y)为圆心绘制一条弧线，弧线半径为 radius，起始和结束角度（用弧度表示）分别为 startAngle 和 endAngle。最后一个参数表示 startAngle 和 endAngle 是否按逆时针方向计算，值为 false 表示按顺时针方向计算。
- arcTo(x1, y1, x2, y2, radius)：从上一点开始绘制一条弧线，到(x2,y2)为止，并且以给定的半径 radius 穿过(x1,y1)。  bezierCurveTo(c1x, c1y, c2x, c2y, x, y)：从上一点开始绘制一条曲线，到(x,y)为止，并且以(c1x,c1y)和(c2x,c2y)为控制点。
- lineTo(x, y)：从上一点开始绘制一条直线，到(x,y)为止。
- moveTo(x, y)：将绘图游标移动到(x,y)，不画线。
- quadraticCurveTo(cx, cy, x, y)：从上一点开始绘制一条二次曲线，到(x,y)为止，并且以(cx,cy)作为控制点。
- rect(x, y, width, height)：从点(x,y)开始绘制一个矩形，宽度和高度分别由 width 和 height 指定。这个方法绘制的是矩形路径，而不是 strokeRect()和 fillRect()所绘制的独立的形状。

2. 创建完路径后，如果想绘制一条连接到路径起点的线条，可以调用 closePath()；
3. 如果路径已经完成，你想用 fillStyle 填充它，可以调用 fill()方法。
4. 可以调用 stroke()方法对路径描边，描边使用的是 strokeStyle
5. 调用 clip()，这个方法可以在路径上创建一个剪切区域

```
// 一个不带数字的简易时钟
//html代码
<canvas id="drawing" width=" 200" height="200">A drawing of something.</canvas>

//js代码
var drawing = document.getElementById("drawing");
//确定浏览器支持<canvas>元素
if (drawing.getContext){
 var context = drawing.getContext("2d");
 //开始路径
 context.beginPath();
 //绘制外圆
context.arc(100, 100, 99, 0, 2 * Math.PI, false);
//绘制内圆
context.moveTo(194, 100);
context.arc(100, 100, 94, 0, 2 * Math.PI, false);
//绘制分针
context.moveTo(100, 100);
context.lineTo(100, 15);
//绘制时针
context.moveTo(100, 100);
context.lineTo(35, 100);
 //描边路径
 context.stroke();
}
```

6. isPointInPath()的方法。这个方法接收 x 和 y 坐标作为参数，用于在路径被关闭之前确定画布上的某一点是否位于路径上

#### 绘制文本

1. 绘制文本主要有两个方法：fillText()和 strokeText()。这两个方法都可以接收 4 个参数：要绘制的文本字符串、x 坐标、y 坐标和可选的最大像素宽度。而且，这两个方法都以下列 3 个属性为基础。

- font：表示文本样式、大小及字体，用 CSS 中指定字体的格式来指定，例如"10px Arial"。
- textAlign：表示文本对齐方式。可能的值有"start"、"end"、"left"、"right"和"center"。建议使用"start"和"end"，不要使用"left"和"right"，因为前两者的意思更稳妥，能同时适合从左到右和从右到左显示（阅读）的语言。
- textBaseline：表示文本的基线。可能的值有"top"、"hanging"、"middle"、"alphabetic"、"ideographic"和"bottom"。

2. fillText()方法使用 fillStyle 属性绘制文本，而 strokeText()方法使用 strokeStyle 属性为文本描边

```
context.font = "bold 14px Arial";
context.textAlign = "center";
context.textBaseline = "middle";
context.fillText("12", 100, 20);
```

3. 确定文本大小的方法 measureText()。这个方法接收一个参数，即要绘制的文本；返回一个 TextMetrics 对象。返回的对象目前只有一个 width 属性

#### 变换

1. 可以通过如下方法来修改变换矩阵

- rotate(angle)：围绕原点旋转图像 angle 弧度。
- scale(scaleX, scaleY)：缩放图像，在 x 方向乘以 scaleX，在 y 方向乘以 scaleY。scaleX 和 scaleY 的默认值都是 1.0。
- translate(x, y)：将坐标原点移动到(x,y)。执行这个变换之后，坐标(0,0)会变成之前由(x,y)表示的点。
- transform(m1_1, m1_2, m2_1, m2_2, dx, dy)：直接修改变换矩阵，方式是乘以如下矩阵。
- setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)：将变换矩阵重置为默认状态，然后再调用 transform()。

2. 如果将来还要返回某组属性与变换的组合，可以调用 save()方法。调用这个方法后，当时的所有设置都会进入一个栈结构，得以妥善保管。然后可以对上下文进行其他修改。等想要回到之前保存的设置时，可以调用 restore()方法，在保存设置的栈结构中向前返回一级，恢复之前的状态。连续调用 save()可以把更多设置保存到栈结构中，之后再连续调用 restore()则可一级一级返回。

#### 绘制图像

1. drawImage()方法把一幅图像绘制到画布上，可以使用三种不同的参数组合

- 传入一个 HTML <img>元素，以及绘制该图像的起点的 x 和 y 坐标

```
var image = document.images[0];
context.drawImage(image, 10, 10);
```

- 在上一种方式的基础上，改变绘制后图像的大小，可以再多传入两个参数，分别表示目标宽度和目标高度

```
//绘制出来的图像大小会变成 20×30 像素
context.drawImage(image, 50, 10, 20, 30);
```

- 把图像中的某个区域绘制到上下文中,drawImage()方法的这种调用方式总共需要传入 9 个参数：要绘制的图像、源图像的 x 坐标、源图像的 y 坐标、源图像的宽度、源图像的高度、目标图像的 x 坐标、目标图像的 y 坐标、目标图像的宽度、目标图像的高度

#### 阴影

1. 上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影。这些属性都可以通过 context 对象来修改

- shadowColor：用 CSS 颜色格式表示的阴影颜色，默认为黑色。
- shadowOffsetX：形状或路径 x 轴方向的阴影偏移量，默认为 0。
- shadowOffsetY：形状或路径 y 轴方向的阴影偏移量，默认为 0。
- shadowBlur：模糊的像素数，默认 0，即不模糊。

#### 渐变

1. 要创建一个新的线性渐变，可以调用 createLinearGradient()方法。这个方法接收 4 个参数：起点的 x 坐标、起点的 y 坐标、终点的 x 坐标、终点的 y 坐标。调用这个方法后，它就会创建一个指定大小的渐变，并返回 CanvasGradient 对象的实例
2. 创建了渐变对象后，下一步就是使用 addColorStop()方法来指定色标。这个方法接收两个参数：色标位置和 CSS 颜色值。色标位置是一个 0（开始的颜色）到 1（结束的颜色）之间的数字

```
//与fillStyle 或 strokeStyle配合使用
var gradient = context.createLinearGradient(30, 30, 70, 70);
gradient.addColorStop(0, "white");
gradient.addColorStop(1, "black");
//绘制渐变矩形
context.fillStyle = gradient;
context.fillRect(30, 30, 50, 50);
```

3. 要创建径向渐变（或放射渐变），可以使用 createRadialGradient()方法。这个方法接收 6 个参数，对应着两个圆的圆心和半径。前三个参数指定的是起点圆的原心（x 和 y）及半径，后三个参数指定的是终点圆的原心（x 和 y）及半径

#### 模式

1. 模式其实就是重复的图像，可以用来填充或描边图形。要创建一个新模式，可以调用 createPattern()方法并传入两个参数：一个 HTML <img>元素和一个表示如何重复图像的字符串。其中，第二个参数的值包括"repeat"、"repeat-x"、"repeat-y"和"no-repeat"。

#### 使用图像数据

1. 通过 getImageData()取得原始图像数据。这个方法接收 4 个参数：要取得其数据的画面区域的 x 和 y 坐标以及该区域的像素宽度和高度，返回的对象是 ImageData 的实例。每个 ImageData 对象都有三个属性：width、height 和 data。其中 data 属性是一个数组，保存着图像中每一个像素的数据

#### 合成

两个会应用到 2D 上下文中所有绘制操作的属性

1. globalAlpha 是一个介于 0 和 1 之间的值（包括 0 和 1），用于指定所有绘制的透明度。默认值为 0
2. globalCompositionOperation 表示后绘制的图形怎样与先绘制的图形结合。这个属性的值是字符串![](JavaScript高级程序设计_files/3.jpg)

### WebGL，暂时略过

#### 类型化数组

#### WebGL 上下文

#### 支持

## HTML5 脚本编程

### 跨文档消息传递

1. 跨文档消息传送（cross-document messaging）简称为 XDM，指的是在来自不同域的页面间传递消息
2. XDM 的核心是 postMessage()方法，接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方

```
//注意：所有支持 XDM 的浏览器也支持 iframe 的 contentWindow 属性
var iframeWindow = document.getElementById("myframe").contentWindow;
iframeWindow.postMessage("A secret", "http://www.wrox.com");
```

3. 接收到 XDM 消息时，会触发 window 对象的 message 事件(异步，接受信息会有延迟),触发 message 事件后，传递给 onmessage 处理程序的事件对象包含以下三方面的重要信息

- data：作为 postMessage()第一个参数传入的字符串数据。
- origin：发送消息的文档所在的域，例如"http://www.wrox.com"。
- source：发送消息的文档的 window 对象的代理。这个代理对象主要用于在发送上一条消息的窗口中调用 postMessage()方法。如果发送消息的窗口来自同一个域，那这个对象就是 window。不能通过这个代理对象访问 window 对象的其他任何信息

### 原生拖放，按住鼠标不放就可以拖动它

#### 拖放事件

1. 拖动某元素时，将依次触发下列事件

- dragstart ，按下鼠标键并开始移动鼠标时
- drag ，在元素被拖动期间会持续触发该事件
- dragend，拖动停止时

2. 当某个元素被拖动到一个有效的放置目标上时，下列事件会依次发生：

- dragenter ，只要有元素被拖动到放置目标上才回触发
- dragover ，在被拖动的元素还在放置目标的范围内移动时，就会持续触发该事件
- dragleave 或 drop，元素被拖出了放置目标

#### 自定义放置目标

有些元素默认是不允许放置的，可以把任何元素变成有效的放置目标，方法是重写 dragenter 和 dragover 事件的默认行为

#### dataTransfer 对象

1. dataTransfer 对象，它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据，它是事件对象的属性，所以只能在拖放事件的事件处理程序中访问 dataTransfer 对象
2. dataTransfer 对象有两个主要方法：getData()和 setData()

#### dropEffect 与 effectAllowed

1. 通过 dropEffect 属性可以知道被拖动的元素能够执行哪种放置行为

- "none"：不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。
- "move"：应该把拖动的元素移动到放置目标。
- "copy"：应该把拖动的元素复制到放置目标。
- "link"：表示放置目标会打开拖动的元素（但拖动的元素必须是一个链接，有 URL）。

2. dropEffect 属性只有搭配 effectAllowed 属性才有用。effectAllowed 属性表示允许拖动元素的哪种 dropEffect，effectAllowed 属性可能的值如下

- "uninitialized"：没有给被拖动的元素设置任何放置行为。
- "none"：被拖动的元素不能有任何行为。
- "copy"：只允许值为"copy"的 dropEffect。
- "link"：只允许值为"link"的 dropEffect。
- "move"：只允许值为"move"的 dropEffect。
- "copyLink"：允许值为"copy"和"link"的 dropEffect。
- "copyMove"：允许值为"copy"和"move"的 dropEffect。
- "linkMove"：允许值为"link"和"move"的 dropEffect。
- "all"：允许任意 dropEffect。

#### 可拖动

1. draggable 属性，表示元素是否可以拖动，图像和链接的 draggable 属性自动被设置成了 true，而其他元素这个属性的默认值都是 false，要改变可以设置

#### 其他成员

### 媒体元素，<audio>和<video>。

#### 属性

1. <audio>和<video>共有属性:![](JavaScript高级程序设计_files/4.jpg)![](JavaScript高级程序设计_files/5.jpg)

#### 事件

媒体元素相关的事件![](JavaScript高级程序设计_files/8.jpg)

#### 自定义媒体播放器

1. 使用<audio>和<video>元素的 play()和 pause()方法，可以手工控制媒体文件的播放。组合使
   用属性、事件和这两个方法，很容易创建一个自定义的媒体播放器

#### 检测编解码器的支持情况

1. canPlayType()方法，该方法接收一种格式/编解码器字符串，返回"probably"、"maybe"或""（ 空字符串）

#### Audio 类型

### 历史状态管理

## 错误处理和调试

### 浏览器报错

#### IE

#### 火狐

#### Safari

#### Opera

#### Chrome

### 错误处理

#### try-catch 语句，跟 Java 一样的

1. 语法

```
try{
 // 可能会导致错误的代码
} catch(error){
 // 在错误发生时怎么处理
}
```

2. 运行机制：如果 try 块中的任何代码发生了错误，就会立即退出代码执行过程，然后接着执行 catch 块。此时，catch 块会接收到一个包含错误信息的对象，该对象有一个保存着错误消息的 message 属性
3. finally 子句，一经使用，其代码无论如何都会执行
4. 注意：只要代码中包含 finally 子句，那么无论 try 还是 catch 语句块中的 return 语句都将被忽略
5. 错误类型

- Error ，基类
- EvalError ，使用 eval()函数而发生异常时被抛出
- RangeError ，数值超出相应范围时触发
- ReferenceError ，找不到对象的情况发生，一般是访问不存在的变量
- SyntaxError ，语法错误
- TypeError ，类型不符，在变量中保存着意外的类型时，或者在访问不存在的方法时
- URIError，使用 encodeURI()或 decodeURI()，而 URI 格式不正确时

6. 当 try-catch 语句中发生错误时，浏览器会认为错误已经被处理了，因而不会通过浏览器的机制记录或报告错误

#### 抛出错误

1. throw 操作符，用于随时抛出自定义错误。抛出错误时，必须要给 throw 操作符指定一个值，这个值没有类型要求
2. 在遇到 throw 操作符时，代码会立即停止执行。仅当有 try-catch 语句捕获到被抛出的值时，代码才会继续执行
3. 通过原生错误类型，可以自定义错误消息

```
throw new SyntaxError("I don’t like your syntax.");
```

4. 可以通过原型链自定义错误类型

```
function CustomError(message){
 this.name = "CustomError";
 this.message = message;
}
CustomError.prototype = new Error();
throw new CustomError("My message");
```

5. 抛出错误的时机

```
function process(values){
 if (!(values instanceof Array)){
 throw new Error("process(): Argument must be an array.");
 }
 values.sort();
 for (var i=0, len=values.length; i < len; i++){
 if (values[i] > 100){
 return values[i];
 }
 }
 return -1;
}
```

6. 抛出错误与使用 try-catch，只应该捕获那些你确切地知道该如何处理的错误。捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息

#### 错误（error）事件

任何没有通过 try-catch 处理的错误都会触发 window 对象的 error 事件，在任何 Web 浏览器中，onerror 事件处理程序都不会创建 event 对象，但它可以接收三个参数：错误消息、错误所在的 URL 和行号。多数情况下，只有错误消息有用

#### 处理错误的策略

#### 常见的错误类型

1. 类型转换错误
2. 数据类型错误
3. 通信错误

#### 区分致命错误和非致命错误

1. 对于非致命错误，可以根据下列一或多个条件来确定：

- 不影响用户的主要任务；
- 只影响页面的一部分；
- 可以恢复；
- 重复相同操作可以消除错误。

2. 致命错误：

- 应用程序根本无法继续运行；
- 错误明显影响到了用户的主要操作；
- 会导致其他连带错误

#### 把错误记录到服务器，错误日志

1. 要建立这样一种 JavaScript 错误记录系统，首先需要在服务器上创建一个页面（或者一个服务器入口点），用于处理错误数据。这个页面的作用无非就是从查询字符串中取得数据，然后再将数据写入错误日志中，这个页面可能使用这样的函数

```
function logError(sev, msg){
 var img = new Image();
 img.src = "log.php?sev=" + encodeURIComponent(sev) + "&msg=" +
 encodeURIComponent(msg);
}
```

2. 只要是使用 try-catch 语句，就应该把相应错误记录到日志中

```
for (var i=0, len=mods.length; i < len; i++){
 try {
 mods[i].init();
 } catch (ex){
 logError("nonfatal", "Module init failed: " + ex.message);
 }
}
```

### 调试技术

#### 把消息记录到控制台，console

#### 把消息记录到当前页面，过时啦

#### 抛出错误

1. 使用 throw

```
function divide(num1, num2){
 if (typeof num1 != "number" || typeof num2 != "number"){
 throw new Error("divide(): Both arguments must be numbers.");
 }
 return num1 / num2;
}
```

2. 对于大型应用程序来说，自定义的错误通常都使用 assert()函数抛出。这个函数接受两个参数，一个是求值结果应该为 true 的条件，另一个是条件为 false 时要抛出的错误

```
function assert(condition, message){
 if (!condition){
 throw new Error(message);
 }
}
//示例
function divide(num1, num2){
 assert(typeof num1 == "number" && typeof num2 == "number",
 "divide(): Both arguments must be numbers.");
 return num1 / num2;
}

```

### 常见 IE 错误

#### 操作终止 operation aborted

1. 在修改尚未加载完成的页面时，就会发生操作终止错误。发生错误时，会出现一个模态对话框，告诉你“操作终止。”单击确定（OK）按钮，则卸载整个页面，继而显示一张空白屏幕

#### 无效字符 invalid character

#### 未找到成员 Member not found，一般是于垃圾收集例程配合错误所直接导致

#### 未知运行时错误 Unknown runtime error，一是把块元素插入到行内元素时，二是访问表格任意部分（<table>、<tbody>等）的任意属性时

#### 语法错误 syntax error

#### 系统无法找到指定资源 The system cannot locate the resource specified

## JavaScript 与 XML，跳过

## E4X，也是跟 XML 有关，跳过

## JSON，是一种数据格式，不从属于 JavaScript，别的语音也可以用

### 语法

1. JSON 的语法可以表示以下三种类型的值

- 简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。 但 JSON 不支持 JavaScript 中的特殊值 undefined。 
- 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。
- 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。

2. JSON 不支持变量、函数或对象实例，它就是一种表示结构化数据的格式

#### 简单值

1. JSON 字符串必须使用双引号

#### 对象

1. JSON 中的对象要求给属性加引号

```
{
 "name": "Nicholas",
 "age": 29
}
```

2. 与 js 的对象字面量的区别

- 没有声明变量，json 中没有变量的概念
- 没有末尾的分号，因为不是 js 语句

3. 属性的值可以是简单值，也可以是复杂类型值包括对象
4. 同一个对象中绝对不应该出现两个同名属性

#### 数组

1. JSON 数组采用的就是 JavaScript 中的数组字面量形式

```
//没有变量和分号
[25, "hi", true]
```

2. 对象和数组可以结合使用

### 解析与序列化

可以把 JSON 数据结构解析为有用的 JavaScript 对象，代码精简

#### json 对象

1. JSON 对象有两个方法：stringify()和 parse()。在最简单的情况下，这两个方法分别用于把 JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值
2. stringify()示例

```
var book = {
 title: "Professional JavaScript",
 authors: [
 "Nicholas C. Zakas"
 ],
 edition: 3,
 year: 2011
 };
var jsonText = JSON.stringify(book);
```

- 默认情况下，JSON.stringify()输出的 JSON 字符串不包含任何空格字符或缩进,因此保存在 jsonText 中的字符串如下所示：

```
{"title":"Professional JavaScript","authors":["Nicholas C. Zakas"],"edition":3,
"year":2011}
```

- 在序列化 JavaScript 对象时，所有函数及原型成员都会被有意忽略，不体现在结果中。此外，值为 undefined 的任何属性也都会被跳过。结果中最终都是值为有效 JSON 数据类型的实例属性

3. parse()示例

```
//创建与 book 类似的对象
var bookCopy = JSON.parse(jsonText);
```

- book 与 bookCopy 具有相同的属性，但它们是两个独立的、没有任何关系的对象

#### 序列化选项

1. JSON.stringify()除了要序列化的 JavaScript 对象外，还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化 JavaScript 对象，第一个参数是个过滤器，可以是一个数组，也可以是一个函数；第二个参数是一个选项，表示是否在 JSON 字符串中保留缩进
2. 过滤结果

- 如果过滤器参数是数组，那么 JSON.stringify()的结果中将只包含数组中列出的属性

```
var book = {
 "title": "Professional JavaScript",
 "authors": [
 "Nicholas C. Zakas"
 ],
 edition: 3,
 year: 2011
 };
var jsonText = JSON.stringify(book, ["title", "edition"]);

//json结果
{"title":"Professional JavaScript","edition":3}
```

- 第二个参数是函数，传入的函数接收两个参数，属性（键）名和属性值，函数返回的值就是相应键的值，如果函数返回了 undefined，那么相应的属性会被忽略

3. 字符串缩进，JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每个级别缩进的空格数
4. toJSON()方法，在 stringify()不能满足序列化需求时，可以给对象定义 toJSON()方法，返回其自身的 JSON 数据格式，可以为任何对象添加 toJSON()方法

```
var book = {
 "title": "Professional JavaScript",
 "authors": [
 "Nicholas C. Zakas"
 ],
 edition: 3,
 year: 2011,
 toJSON: function(){
 return this.title;
  }
  };
 var jsonText = JSON.stringify(book);
```

5. 把一个对象传入 JSON.stringify()，序列化该对象的顺序如下

- 如果存在 toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。
- 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。
- 对第(2)步返回的每个值进行相应的序列化。
- 如果提供了第三个参数，执行相应的格式化。

#### 解析选项

1. JSON.parse()方法也可以接收另一个参数，该参数是一个函数（还原函数），将在每个键值对儿上调用
2. 如果还原函数返回 undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中，在将日期字符串转换为 Date 对象时，经常要用到还原函数

```
var book = {
 "title": "Professional JavaScript",
 "authors": [
 "Nicholas C. Zakas"
 ],
 edition: 3,
 year: 2011,
 releaseDate: new Date(2011, 11, 1)
 };
var jsonText = JSON.stringify(book);
var bookCopy = JSON.parse(jsonText, function(key, value){
 if (key == "releaseDate"){
 return new Date(value);
 } else {
 return value;
 }
 });
```

## Ajax 与 Comet

Ajax 能够向服务器请求额外的数据而无须卸载页面, 技术的核心是 XMLHttpRequest 对象（简称 XHR）

### XMLHttpRequest 对象

1. IE7 以前使用 MSXML 库中的 XHR 对象

```
//适用于 IE7 之前的版本
function createXHR(){
 if (typeof arguments.callee.activeXString != "string"){
 var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0",
 "MSXML2.XMLHttp"],
 i, len;
 for (i=0,len=versions.length; i < len; i++){
 try {
 new ActiveXObject(versions[i]);
 arguments.callee.activeXString = versions[i];
 break;
 } catch (ex){
 //跳过
 }
 }
 }
 return new ActiveXObject(arguments.callee.activeXString);
}
```

2. IE7 之后用 XMLHttpRequest 构造函数。

```
var xhr = new XMLHttpRequest();
```

3. 兼容 IE7 与新的

```
function createXHR(){
 if (typeof XMLHttpRequest != "undefined"){
 return new XMLHttpRequest();
 } else if (typeof ActiveXObject != "undefined"){
 if (typeof arguments.callee.activeXString != "string"){
 var versions = [ "MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0",
 "MSXML2.XMLHttp"],
 i, len;
 for (i=0,len=versions.length; i < len; i++){
 try {
 new ActiveXObject(versions[i]);
 arguments.callee.activeXString = versions[i];
 break;
 } catch (ex){
 //跳过
 }
 }
 }
 return new ActiveXObject(arguments.callee.activeXString);
 } else {
 throw new Error("No XHR object available.");
 }
}
```

#### XHR 的用法

1. 使用 XHR 对象时，要调用的第一个方法是 open()，它接受 3 个参数：要发送的请求的类型（"get"、"post"等）、请求的 URL 和表示是否异步发送请求的布尔值

```
//启动一个针对 example.php 的 GET 请求
xhr.open("get", "example.php", false);
```

- URL 相对于执行代码的当前页面（当然也可以使用绝对路径）
- 调用 open()方法并不会真正发送请求，而只是启动一个请求以备发送
- 只能向同一个域中使用相同端口和协议的 URL 发送请求

2. 要发送特定的请求，必须像下面这样调用 send()方法将请求发送到服务器：send()方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据，则必须传入 null.

```
xhr.open("get", "example.txt", false);
xhr.send(null);
```

- 这次请求是同步的，JavaScript 代码会等到服务器响应之后再继续执行
- 收到响应后，响应的数据会自动填充 XHR 对象的属性 + responseText：作为响应主体被返回的文本。 + responseXML：如果响应的内容类型是"text/xml"或"application/xml"，这个属性中将保存包含着响应数据的 XML DOM 文档。 + status：响应的 HTTP 状态。 + statusText：HTTP 状态的说明。
- 为确保接收到适当的响应，应该像下面这样检查上述这两种状态代码

```
xhr.open("get", "example.txt", false);
xhr.send(null);
if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
 alert(xhr.responseText);
} else {
 alert("Request was unsuccessful: " + xhr.status);
}
```

3. 发送异步请求，此时，可以检测 XHR 对象的 readyState 属性，该属性表示请求/响应过程的当前活动阶段，这个属性的取值有

- 0：未初始化。尚未调用 open()方法。
- 1：启动，服务器连接已经建立。已经调用 open()方法，但尚未调用 send()方法。
- 2：发送。已经调用 send()方法，但尚未接收到响应。
- 3：接收。已经接收到部分响应数据。
- 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了

4. 只要 readyState 属性的值由一个值变成另一个值，都会触发一次 readystatechange 事件，通常，我们只对 readyState 值为 4 的阶段感兴趣，因为这时所有数据都已经就绪,注意必须在调用 open()之前指定 onreadystatechange 事件处理程序才能确保跨浏览器兼容性

```
var xhr = createXHR();
xhr.onreadystatechange = function(){
if (xhr.readyState == 4){
if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
alert(xhr.responseText);
} else {
alert("Request was unsuccessful: " + xhr.status);
}
}
};
xhr.open("get", "example.txt", true);
xhr.send(null);
```

5. 在接收到响应之前还可以调用 abort()方法来取消异步请求

```
//XHR 对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性
xhr.abort();
```

#### HTTP 头部信息

1. 默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。

- Accept：浏览器能够处理的内容类型。
- Accept-Charset：浏览器能够显示的字符集。
- Accept-Encoding：浏览器能够处理的压缩编码。
- Accept-Language：浏览器当前设置的语言。
- Connection：浏览器与服务器之间连接的类型。
- Cookie：当前页面设置的任何 Cookie。
- Host：发出请求的页面所在的域 。
- Referer：发出请求的页面的 URI。注意，HTTP 规范将这个头部字段拼写错了，而为保证与规范一致，也只能将错就错了。（这个英文单词的正确拼法应该是 referrer。）
- User-Agent：浏览器的用户代理字符串。

2. 使用 setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段的名称和头部字段的值，要成功发送请求头部信息，必须在调用 open()方法之后且调用 send()方法之前调用 setRequestHeader()

```
var xhr = createXHR();
xhr.onreadystatechange = function(){
 if (xhr.readyState == 4){
 if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
 alert(xhr.responseText);
 } else {
 alert("Request was unsuccessful: " + xhr.status);
 }
 }
 };
 xhr.open("get", "example.php", true);
 xhr.setRequestHeader("MyHeader", "MyValue");
 xhr.send(null);
```

3. 调用 XHR 对象的 getResponseHeader()方法并传入头部字段名称，可以取得相应的响应头部信息。而调用 getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串。

```
var myHeader = xhr.getResponseHeader("MyHeader");
var allHeaders = xhr.getAllResponseHeaders();
```

#### GET 请求

1. 使用 GET 请求经常会发生的一个错误，就是查询字符串的格式有问题，查询字符串中每个参数的名称和值都必须使用 encodeURIComponent()进行编码，而且所有名-值对儿都必须由和号（&）分隔

```
//这个函数可以辅助向现有 URL 的末尾添加查询字符串参数
function addURLParam(url, name, value) {
 url += (url.indexOf("?") == -1 ? "?" : "&");
 url += encodeURIComponent(name) + "=" + encodeURIComponent(value);
 return url;
}
//使用示例
var url = "example.php";
//添加参数
url = addURLParam(url, "name", "Nicholas");
url = addURLParam(url, "book", "Professional JavaScript");
//初始化请求
xhr.open("get", url, false);
```

#### POST 请求

1. 在 open()方法第一个参数的位置传入"post"，就可以初始化一个 POST 请求

```
xhr.open("post", "example.php", true);
```

2. 发送 POST 请求的第二步就是向 send()方法中传入某些数据

### XMLHttpRequest 2 级

#### FormData

1. FormData 为序列化表单以及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利。

```
var data = new FormData();
//append()方法接收两个参数：键和值，分别对应表单字段的名字和字段中包含的值
data.append("name", "Nicholas");
//用表单元素的数据预先向其中填入键值对儿
var data = new FormData(document.forms[0]);
```

2. 创建了 FormData 的实例后，可以将它直接传给 XHR 的 send()方法

```
var xhr = createXHR();
xhr.onreadystatechange = function(){
 if (xhr.readyState == 4){
 if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
 alert(xhr.responseText);
 } else {
  alert("Request was unsuccessful: " + xhr.status);
  }
  }
 };
 xhr.open("post","postexample.php", true);
 var form = document.getElementById("user-info");
 xhr.send(new FormData(form));
```

#### 超时设定，兼容性差

1. timeout 属性，表示请求在等待响应多少毫秒之后就终止，在给 timeout 设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发 timeout 事件，进而会调用 ontimeout 事件处理程序

#### overrideMimeType()方法

1. overrideMimeType()方法，用于重写 XHR 响应的 MIME 类型

### 进度事件，了解就好

1. 有 6 个进度事件

- loadstart：在接收到响应数据的第一个字节时触发。
- progress：在接收响应期间持续不断地触发。
- error：在请求发生错误时触发。
- abort：在因为调用 abort()方法而终止连接时触发。
- load：在接收到完整的响应数据时触发。
- loadend：在通信完成或者触发 error、abort 或 load 事件后触发。

2. 每个请求都从触发 loadstart 事件开始，接下来是一或多个 progress 事件，然后触发 error、abort 或 load 事件中的一个，最后以触发 loadend 事件结束。

#### load 事件

1. load 事件，用以替代 readystatechange 事件。响应接收完毕后将触发 load 事件，因此也就没有必要去检查 readyState 属性
2. onload 事件处理程序会接收到一个 event 对象，其 target 属性就指向 XHR 对象实例，因而可以访问到 XHR 对象的所有方法和属性
3. 为保证兼容性,还是要检查 status

```
var xhr = createXHR();
xhr.onload = function(){
 if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
 alert(xhr.responseText);
 } else {
 alert("Request was unsuccessful: " + xhr.status);
 }
};
xhr.open("get", "altevents.php", true);
xhr.send(null);
```

#### progress 事件

1. progress 事件，这个事件会在浏览器接收新数据期间周期性地触发，onprogress 事件处理程序会接收到一个 event 对象，其 target 属性是 XHR 对象，但包含着三个额外的属性：lengthComputable、position 和 totalSize

- lengthComputable 是一个表示进度信息是否可用的布尔值
- position 表示已经接收的字节数
- totalSize 表示根据 Content-Length 响应头部确定的预期字节数

```
//运用示例
var xhr = createXHR();
xhr.onload = function(event){
 if ((xhr.status >= 200 && xhr.status < 300) ||
 xhr.status == 304){
 alert(xhr.responseText);
 } else {
 alert("Request was unsuccessful: " + xhr.status);
 }
};
xhr.onprogress = function(event){
 var divStatus = document.getElementById("status");
 if (event.lengthComputable){
 divStatus.innerHTML = "Received " + event.position + " of " +
 event.totalSize +" bytes";
 }
};
xhr.open("get", "altevents.php", true);
xhr.send(null);
```

### 跨资源共享 CORS（Cross-Origin Resource Sharing

1. 默认情况下，XHR 对象只能访问与包含它的页面位于同一个域中的资源，CORS 的出现是为了实现合理的跨域请求
1. CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败
